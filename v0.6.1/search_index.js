var documenterSearchIndex = {"docs":
[{"location":"Dev/future/#Future-Work","page":"Future Work","title":"Future Work","text":"","category":"section"},{"location":"Dev/future/#Current-Activity:","page":"Future Work","title":"Current Activity:","text":"","category":"section"},{"location":"Dev/future/","page":"Future Work","title":"Future Work","text":"Update CI testing.\nSpecialized algorithms for relaxing ODE constrained problems and solving global and robust optimization problems.\nExtensions for nonconvex dynamic global & robust optimization.\nProvide support for mixed-integer problems.\nUpdate EAGO to support nonsmooth problems (requires: a nonsmooth local nlp optimizer or lexiographic AD, support for relaxations is already included).\nEvaluation and incorporation of implicit relaxation routines in basic solver.","category":"page"},{"location":"Dev/future/#Other-things-on-the-wishlist-(but-not-actively-being-worked-on):","page":"Future Work","title":"Other things on the wishlist (but not actively being worked on):","text":"","category":"section"},{"location":"Dev/future/","page":"Future Work","title":"Future Work","text":"Implement the interval constraint propagation scheme presented in Vu 2008. For improved convergences.\nA parametric bisection routine will be updated that can divide the (X,P) space into a series of boxes that all contain unique branches of the implicit function p->y(p).\nProvide a better interface the nonconvex semi-infinite programs solvers (JuMPeR extension?).\nAdd additional McCormick relaxations.\nAdd handling for domain reduction of special expression forms.","category":"page"},{"location":"McCormick/implicit/#Relaxation-of-Implicit-Functions","page":"Relaxation of Implicit Functions","title":"Relaxation of Implicit Functions","text":"","category":"section"},{"location":"McCormick/implicit/#High-level-functions","page":"Relaxation of Implicit Functions","title":"High-level functions","text":"","category":"section"},{"location":"McCormick/implicit/","page":"Relaxation of Implicit Functions","title":"Relaxation of Implicit Functions","text":"implicit_relax_h!","category":"page"},{"location":"McCormick/implicit/#McCormick.implicit_relax_h!","page":"Relaxation of Implicit Functions","title":"McCormick.implicit_relax_h!","text":"implicit_relax_h!(d)\nimplicit_relax_h!(d, interval_bnds)\n\n\nCompute relaxations of x(p) defined by h(x,p) = 0 where h is specifed as h(out, x, p).\n\n\n\n\n\n","category":"function"},{"location":"McCormick/implicit/#DataStructures","page":"Relaxation of Implicit Functions","title":"DataStructures","text":"","category":"section"},{"location":"McCormick/implicit/","page":"Relaxation of Implicit Functions","title":"Relaxation of Implicit Functions","text":"McCormick.AbstractContractorMC\nNewtonGS\nKrawczykCW\nMcCormick.AbstractPreconditionerMC\nDenseMidInv\nMcCormick.AbstractMCCallback\nMCCallback","category":"page"},{"location":"McCormick/implicit/#McCormick.AbstractContractorMC","page":"Relaxation of Implicit Functions","title":"McCormick.AbstractContractorMC","text":"abstract type AbstractContractorMC\n\nAn abstract type for each manner of contractor using in the implicit function relaxation algorithms.\n\n\n\n\n\n","category":"type"},{"location":"McCormick/implicit/#McCormick.NewtonGS","page":"Relaxation of Implicit Functions","title":"McCormick.NewtonGS","text":"struct NewtonGS <: McCormick.AbstractContractorMC\n\nThe Gauss-Seidel implementation of the Newton contractor used in the implicit relaxation scheme.\n\n\n\n\n\n","category":"type"},{"location":"McCormick/implicit/#McCormick.KrawczykCW","page":"Relaxation of Implicit Functions","title":"McCormick.KrawczykCW","text":"struct KrawczykCW <: McCormick.AbstractContractorMC\n\nThe componentwise implementation of the Krawczyk contractor used in the implicit relaxation scheme.\n\n\n\n\n\n","category":"type"},{"location":"McCormick/implicit/#McCormick.AbstractPreconditionerMC","page":"Relaxation of Implicit Functions","title":"McCormick.AbstractPreconditionerMC","text":"abstract type AbstractPreconditionerMC\n\nAn abstract type for each manner of preconditioner used in the implicit function relaxation algorithms.\n\n\n\n\n\n","category":"type"},{"location":"McCormick/implicit/#McCormick.DenseMidInv","page":"Relaxation of Implicit Functions","title":"McCormick.DenseMidInv","text":"struct DenseMidInv{S<:Union{Array{Float64,1}, Array{Float64,2}}} <: McCormick.AbstractPreconditionerMC\n\nA dense LU preconditioner for implicit McCormick relaxation.\n\n\n\n\n\n","category":"type"},{"location":"McCormick/implicit/#McCormick.AbstractMCCallback","page":"Relaxation of Implicit Functions","title":"McCormick.AbstractMCCallback","text":"abstract type AbstractMCCallback\n\nAn abstract type for each manner of callback functions used in the implicit function relaxation algorithms.\n\n\n\n\n\n","category":"type"},{"location":"McCormick/implicit/#McCormick.MCCallback","page":"Relaxation of Implicit Functions","title":"McCormick.MCCallback","text":"struct MCCallback{FH<:Function, FJ<:Function, C<:McCormick.AbstractContractorMC, PRE<:McCormick.AbstractPreconditionerMC, N, T<:RelaxTag, AMAT<:(AbstractArray{T,2} where T)} <: AbstractMCCallback\n\nA structure used to compute implicit relaxations.\n\nh!::Function\nFunction h(x,p) = 0 defined in place by h!(out,x,p)\nhj!::Function\nJacobian of h(x,p) w.r.t x\nH::Array{MC{N,T},1} where T<:RelaxTag where N\n\nJ::AbstractArray{T,2} where T\n\nxmid::Array{Float64,1}\nX::Array{Interval{Float64},1}\nP::Array{Interval{Float64},1}\nnx::Int64\nState space dimension\nnp::Int64\nDecision space dimension\nlambda::Float64\nConvex combination parameter\neps::Float64\nTolerance for interval equality\nkmax::Int64\nNumber of contractor steps to take\npref_mc::Array{MC{N,T},1} where T<:RelaxTag where N\np_mc::Array{MC{N,T},1} where T<:RelaxTag where N\nx0_mc::Array{MC{N,T},1} where T<:RelaxTag where N\nx_mc::Array{MC{N,T},1} where T<:RelaxTag where N\nxa_mc::Array{MC{N,T},1} where T<:RelaxTag where N\nxA_mc::Array{MC{N,T},1} where T<:RelaxTag where N\naff_mc::Array{MC{N,T},1} where T<:RelaxTag where N\nz_mc::Array{MC{N,T},1} where T<:RelaxTag where N\ncontractor::McCormick.AbstractContractorMC\nType of contractor used in implicit relaxation routine.\npreconditioner::McCormick.AbstractPreconditionerMC\nPreconditioner used in the implicit relaxation routine.\napply_precond::Bool\nBoolean indicating that the preconditioner should be applied\nparam::Array{Array{MC{N,T},1},1} where T<:RelaxTag where N\n\n\n\n\n\n","category":"type"},{"location":"McCormick/implicit/#Subroutines","page":"Relaxation of Implicit Functions","title":"Subroutines","text":"","category":"section"},{"location":"McCormick/implicit/","page":"Relaxation of Implicit Functions","title":"Relaxation of Implicit Functions","text":"preconditioner_storage\naffine_exp!\ncorrect_exp!\ncontract!\nprecond_and_contract!\nfinal_cut\ngen_expansion_params!\npopulate_affine!","category":"page"},{"location":"McCormick/implicit/#McCormick.preconditioner_storage","page":"Relaxation of Implicit Functions","title":"McCormick.preconditioner_storage","text":"preconditioner_storage(x, t)\n\n\nCreates storage corresponding to x::AbstractPreconditionerMC and t::T where T<:RelaxTag.\n\n\n\n\n\n","category":"function"},{"location":"McCormick/implicit/#McCormick.affine_exp!","page":"Relaxation of Implicit Functions","title":"McCormick.affine_exp!","text":"affine_exp!(x, p, d)\n\n\nComputates the affine relaxations of the state variable.\n\n\n\n\n\n","category":"function"},{"location":"McCormick/implicit/#McCormick.correct_exp!","page":"Relaxation of Implicit Functions","title":"McCormick.correct_exp!","text":"Corrects the relaxation of the state variable x_mc if the affine relaxation,\n\n\n\n\n\n","category":"function"},{"location":"McCormick/implicit/#McCormick.contract!","page":"Relaxation of Implicit Functions","title":"McCormick.contract!","text":"Performs a single step of the parametric method associated with t assumes that the inputs have been preconditioned.\n\n\n\n\n\n","category":"function"},{"location":"McCormick/implicit/#McCormick.precond_and_contract!","page":"Relaxation of Implicit Functions","title":"McCormick.precond_and_contract!","text":"\n\n\n\n","category":"function"},{"location":"McCormick/implicit/#McCormick.final_cut","page":"Relaxation of Implicit Functions","title":"McCormick.final_cut","text":"final_cut(x, y)\n\n\nAn operator that cuts the x object using the y bounds in a differentiable or nonsmooth fashion to achieve a composite relaxation within y.\n\n\n\n\n\n","category":"function"},{"location":"McCormick/implicit/#McCormick.gen_expansion_params!","page":"Relaxation of Implicit Functions","title":"McCormick.gen_expansion_params!","text":"gen_expansion_params!(d)\ngen_expansion_params!(d, interval_bnds)\n\n\nConstructs parameters need to compute relaxations of h.\n\n\n\n\n\n","category":"function"},{"location":"McCormick/implicit/#McCormick.populate_affine!","page":"Relaxation of Implicit Functions","title":"McCormick.populate_affine!","text":"Populates x_mc, xa_mc, xA_mc, and z_mc with affine bounds.\n\n\n\n\n\n","category":"function"},{"location":"Dev/contributing/#How-to-Contribute","page":"How to Contribute","title":"How to Contribute","text":"","category":"section"},{"location":"Dev/contributing/","page":"How to Contribute","title":"How to Contribute","text":"We're always happy to welcome work with additional collaborators and contributors. One of the easy ways for newcomers to contribute is by adding additional relaxations.","category":"page"},{"location":"Dev/contributing/","page":"How to Contribute","title":"How to Contribute","text":"If you're interested in contributing in larger ways, please contact: Matthew Wilhelm","category":"page"},{"location":"Dev/contributing/","page":"How to Contribute","title":"How to Contribute","text":"If you have any requests for additional functionality, bug fixes, or comments please feel free to open a new issue using Github issue tracker.","category":"page"},{"location":"Optimizer/udf_utilities/#User-Define-Functions-and-DAG-Utilities","page":"User-Define Functions and DAG Utilities","title":"User-Define Functions and DAG Utilities","text":"","category":"section"},{"location":"Optimizer/udf_utilities/","page":"User-Define Functions and DAG Utilities","title":"User-Define Functions and DAG Utilities","text":"EAGO has included basic functionality to manipulate user-defined functions. These features are largely experimental and we're interested in providing additional for novel use cases.","category":"page"},{"location":"Optimizer/udf_utilities/#DAG-Substitution-and-Flattening","page":"User-Define Functions and DAG Utilities","title":"DAG Substitution and Flattening","text":"","category":"section"},{"location":"Optimizer/udf_utilities/","page":"User-Define Functions and DAG Utilities","title":"User-Define Functions and DAG Utilities","text":"dag_flattening!\nflatten_expression!\nregister_substitution!\nTemplate_Graph\nTemplate_Node","category":"page"},{"location":"Optimizer/udf_utilities/#EAGO.Script.dag_flattening!","page":"User-Define Functions and DAG Utilities","title":"EAGO.Script.dag_flattening!","text":"dag_flattening!\n\nFlattens (usually) the dag by making all registered substitutions for every nonlinear term in the Optimizer.\n\n\n\n\n\n","category":"function"},{"location":"Optimizer/udf_utilities/#EAGO.Script.flatten_expression!","page":"User-Define Functions and DAG Utilities","title":"EAGO.Script.flatten_expression!","text":"flatten_expression!\n\nFlattens (usually) the dag by making all registered substitutions for the expression expr::_NonlinearExprData. Performs a depth-first search through the expression adding the terminal node to the stack, then checking to determine if it matches a registered substitution pattern. If it doesn't not then node is added to the new expression graph representation and it's children are added to the queue. If an expression (node) is identified as a pattern then it is substituted and any children expression nodes are then checked for patterns until the depth first search is exhausted.\n\n\n\n\n\n","category":"function"},{"location":"Optimizer/udf_utilities/#EAGO.Script.register_substitution!","page":"User-Define Functions and DAG Utilities","title":"EAGO.Script.register_substitution!","text":"register_substitution!\n\nSpecifies that the src::Template_Graph should be subsituted out for the trg::Template_Graph.\n\nConventions for substition, the expression to be checked always appears at key 1 in the Template_Graph and operations are ordered from low value to high value left to right so if 1 is a -, and 4 => 1, 3 => 1 then the expression is 4 - 3\n\n\n\n\n\n","category":"function"},{"location":"Optimizer/udf_utilities/#EAGO.Script.Template_Graph","page":"User-Define Functions and DAG Utilities","title":"EAGO.Script.Template_Graph","text":"Template_Graph\n\nHolds a list of Template_Nodes, set of directed edges, lengths, an adjacency matrix and the number of children.\n\n\n\n\n\n","category":"type"},{"location":"Optimizer/udf_utilities/#EAGO.Script.Template_Node","page":"User-Define Functions and DAG Utilities","title":"EAGO.Script.Template_Node","text":"Template_Node\n\nA structure which holds a symbol indicating whether the node is an operator, a number, or an expression type, a value which identifies the function or symbol value, potentially a numeric value num_value, and a check that can be run to verify the node is correct check.\n\n\n\n\n\n","category":"type"},{"location":"Optimizer/udf_utilities/#User-Defined-Function-(UDF)-Scrubber","page":"User-Define Functions and DAG Utilities","title":"User-Defined Function (UDF) Scrubber","text":"","category":"section"},{"location":"Optimizer/udf_utilities/","page":"User-Define Functions and DAG Utilities","title":"User-Define Functions and DAG Utilities","text":"scrub\nscrub!","category":"page"},{"location":"Optimizer/udf_utilities/#EAGO.Script.scrub","page":"User-Define Functions and DAG Utilities","title":"EAGO.Script.scrub","text":"scrub(f::Function, n::Int, inplace = false)\n\nReplaces storage objects and circumvents assertions that present a UDF from being overloaded with subtype Real objects by creating a function which overdubs f in ScrubCtx.\n\n\n\n\n\n","category":"function"},{"location":"Optimizer/udf_utilities/#EAGO.Script.scrub!","page":"User-Define Functions and DAG Utilities","title":"EAGO.Script.scrub!","text":"scrub!(d::_NLPData)\n\nApplies scrub to every user-defined function in the a _NLPData structure.\n\n\n\n\n\n","category":"function"},{"location":"Optimizer/optimizer/#EAGO-Optimizer","page":"EAGO Optimizer","title":"EAGO Optimizer","text":"","category":"section"},{"location":"Optimizer/optimizer/","page":"EAGO Optimizer","title":"EAGO Optimizer","text":"The EAGO.Optimizer object holds all algorithm solution information. A description of all user-facing options has been provided in the docstring.","category":"page"},{"location":"Optimizer/optimizer/#EAGO.Optimizer","page":"EAGO Optimizer","title":"EAGO.Optimizer","text":"","category":"section"},{"location":"Optimizer/optimizer/","page":"EAGO Optimizer","title":"EAGO Optimizer","text":"Optimizer","category":"page"},{"location":"Optimizer/optimizer/#EAGO.Optimizer","page":"EAGO Optimizer","title":"EAGO.Optimizer","text":"mutable struct Optimizer <: MathOptInterface.AbstractOptimizer\n\nThe main optimizer object used by EAGO to solve problems during the optimization routine. The following commonly used options are described below and can be set via keyword arguments in the JuMP/MOI model. The raw parameter interface however is likely preferable. The Optimizer is organized in the following manner. Parameters which are expected to be constant over the entire solve are stored in _parameters::EAGOParameters field. User-facing keywords not in EAGOParameters field:\n\nrelaxed_optimizer::MOI.AbstractOptimizer: An instance of the optimizer used to solve the relaxed subproblems (default = GLPK.Optimizer())\nobbt_variable_values::Vector{Bool}: Variables to perform OBBT on (default: all variables in nonlinear expressions).\nupper_optimizer::MOI.AbstractOptimizer: Optimizer used to solve upper bounding problems. (default = Ipopt.Optimizer)\nenable_optimize_hook::Bool: Specifies that the optimize_hook! function should be called rather than throw the problem to the standard B&B routine (default = false).\next::Dict{Symbol, Any}: Holds additional storage needed for constructing extensions to EAGO (default = Dict{Symbol,Any}).\next_type::ExtensionType: Holds an instance of a subtype of EAGO.ExtensionType used to define new custom subroutines (default = DefaultExt()).\n\n\n\n\n\n","category":"type"},{"location":"Optimizer/optimizer/#Storage-for-Input-Parameters","page":"EAGO Optimizer","title":"Storage for Input Parameters","text":"","category":"section"},{"location":"Optimizer/optimizer/","page":"EAGO Optimizer","title":"EAGO Optimizer","text":"EAGO.EAGOParameters","category":"page"},{"location":"Optimizer/optimizer/#EAGO.EAGOParameters","page":"EAGO Optimizer","title":"EAGO.EAGOParameters","text":"mutable struct EAGOParameters\n\nStorage for parameters that do not change during a global solve.\n\npresolve_scrubber_flag::Bool\nShould EAGO attempt to remove type assert issues for user-defined functions (default = false)\npresolve_to_JuMP_flag::Bool\nCreate and use DAG representations of user-defined function (default = false).\npresolve_epigraph_flag::Bool\n[FUTURE FEATURE, NOT CURRENTLY IMPLEMENTED] Apply the epigraph reformulation     to the problem (default = false).\npresolve_flatten_flag::Bool\nRerranges the DAG using registered transformations (default = false)\nconic_convert_quadratic::Bool\nAttempt to bridge convex constraint to second order cone\nlog_on::Bool\nTurns logging on records global bounds, node count and run time. Additional      options are available for recording information specific to subproblems (default = false).\nlog_subproblem_info::Bool\nTurns on logging of times and feasibility of subproblems (default = false)\nlog_interval::Int64\nLog data every log_interval iterations (default = 1).\nverbosity::Int64\nThe amount of information that should be printed to console while solving     values range from 0 - 4: 0 is silent, 1 shows iteration summary statistics     only, 2-4 show varying degrees of details about calculations within each     iteration (default = 1).\noutput_iterations::Int64\nDisplay summary of iteration to console every output_iterations (default = 10)\nheader_iterations::Int64\nDisplay header for summary to console every output_iterations (default = 100)\nbranch_cvx_factor::Float64\nConvex coefficient used to select branch point. Branch point is given by     branch_cvx_factor*xmid + (1-branch_cvx_factor)*xsol (default = 0.25)\nbranch_offset::Float64\nMinimum distance from bound to have branch point normalized by width of     dimension to branch on (default = 0.15)\nbranch_variable::Array{Bool,1}\nVariables to branch on (default is all nonlinear).\nbranch_max_repetitions::Int64\n[FUTURE FEATURE, NOT CURRENTLY IMPLEMENTED] Number of times repeat node     processing priorto branching (default = 4).\nbranch_repetition_tol::Float64\n[FUTURE FEATURE, NOT CURRENTLY IMPLEMENTED] Volume ratio tolerance required     to repeat processing the current node (default = 0.9)\nnode_limit::Int64\nMaximum number of nodes (default = 1E-7)\ntime_limit::Float64\nMaximum CPU time in seconds (default = 1000)\niteration_limit::Int64\nMaximum number of iterations (default 3E6)\nabsolute_tolerance::Float64\nAbsolute tolerance for termination (default = 1E-3)\nrelative_tolerance::Float64\nRelative tolerance for termination (default = 1E-3)\nabsolute_constraint_feas_tolerance::Float64\nAbsolute constraint feasibility tolerance\nlocal_solve_only::Bool\nPerform only a local solve of the problem (default = false).\nfeasible_local_continue::Bool\n[TO BE REMOVED] Flag stops B&B loop if feasible point found.\ncp_depth::Int64\nDepth in B&B tree above which constraint propagation should be disabled (default = 1000)\ncp_repetitions::Int64\nNumber of times to repeat forward-reverse pass routine (default = 3)\ncp_tolerance::Float64\nDisable constraint propagation if the ratio of new node volume to beginning node volume exceeds     this number (default = 0.99)\ncp_interval_only::Bool\nUse only valid interval bounds during constraint propagation (default = false)\nobbt_depth::Int64\nDepth in B&B tree above which OBBT should be disabled (default = 6)\nobbt_repetitions::Int64\nNumber of repetitions of OBBT to perform in preprocessing (default = 3)\nobbt_aggressive_on::Bool\nTurn aggresive OBBT on (default = false)\nobbt_aggressive_max_iteration::Int64\nMaximum iteration to perform aggresive OBBT (default = 2)\nobbt_aggressive_min_dimension::Int64\nMinimum dimension to perform aggresive OBBT (default = 2)\nobbt_tolerance::Float64\nTolerance to consider bounds equal (default = 1E-9)\nfbbt_lp_depth::Int64\nDepth in B&B tree above which linear FBBT should be disabled (default = 1000)\nfbbt_lp_repetitions::Int64\nNumber of repetitions of linear FBBT to perform in preprocessing (default = 3)\nquad_uni_depth::Int64\n[FUTURE FEATURE, NOT CURRENTLY IMPLEMENTED] Depth in B&B tree above which univariate quadratic FBBT should be disabled (default = -1)\nquad_uni_repetitions::Int64\n[FUTURE FEATURE, NOT CURRENTLY IMPLEMENTED] Number of repetitions of univariate quadratic FBBT to perform in preprocessing (default = 2)\nquad_bi_depth::Int64\n[FUTURE FEATURE, NOT CURRENTLY IMPLEMENTED] Depth in B&B tree above which bivariate     quadratic FBBT should be disabled (default = -1)\nquad_bi_repetitions::Int64\n[FUTURE FEATURE, NOT CURRENTLY IMPLEMENTED] Number of repetitions of bivariate quadratic FBBT to perform in preprocessing (default = 2).\ndbbt_depth::Int64\nDepth in B&B tree above which duality-based bound tightening should be disabled (default = 1E10)\ndbbt_tolerance::Float64\nNew bound is considered equal to the prior bound if within dbbt_tolerance (default = 1E-9).\nrelax_tag::RelaxTag\nRelax Tag used to specify type of McCormick operator\nsubgrad_tighten::Bool\nPerform tightening of interval bounds using subgradients at each factor in     each nonlinear tape during a forward pass (default = true).\nreverse_subgrad_tighten::Bool\nPerform tightening of interval bounds using subgradients at each factor in     each nonlinear tape during a reverse pass (default = false).\nsubgrad_tol::Float64\nOuter round computed subgradient bounds by this amount\ncut_min_iterations::Int64\nMinimum number of cuts at each node to attempt (unsafe cuts not necessarily added)\ncut_max_iterations::Int64\nMaximum number of cuts at each node to attempt\ncut_cvx::Float64\nConvex coefficient used to select point for new added cuts. Branch point is     given by (1-cut_cvx)*xmid + cut_cvx*xsol (default = 0.9).\ncut_tolerance::Float64\nAdd cut if the L1 distance from the prior cutting point to the new cutting     point normalized by the box volume is greater than the tolerance (default = 0.05).\nobjective_cut_on::Bool\nAdds an objective cut to the relaxed problem (default = true).\ncut_safe_on::Bool\nUse tolerances to determine safe cuts in a Khajavirad 2018 manner\ncut_safe_l::Float64\nLower tolerance for safe-lp cut, Khajavirad 2018\ncut_safe_u::Float64\nUpper tolerance for safe-lp cut, Khajavirad 2018\ncut_safe_b::Float64\nConstant tolerance for safe-lp cut, Khajavirad 2018\nupper_bounding_depth::Int64\nSolve upper problem for every node with depth less than upper_bounding_depth     and with a probabilityof (1/2)^(depth-upperboundingdepth) otherwise (default = 6)\ndomain_violation_guard_on::Bool\nAmount about a domain violation to ignore when propagating bounds.\ndomain_violation_ϵ::Float64\nAmount about a domain violation to ignore when propagating bounds.\n\n\n\n\n\n","category":"type"},{"location":"Optimizer/optimizer/#Internal-Storage-Structures","page":"EAGO Optimizer","title":"Internal Storage Structures","text":"","category":"section"},{"location":"Optimizer/optimizer/","page":"EAGO Optimizer","title":"EAGO Optimizer","text":"VariableInfo\nExtensionType\nLog","category":"page"},{"location":"Optimizer/optimizer/#EAGO.VariableInfo","page":"EAGO Optimizer","title":"EAGO.VariableInfo","text":"mutable struct VariableInfo\n\nA structure used to store information related to the bounds assigned to each variable.\n\nis_integer::Bool\nIs the variable integer valued?\nlower_bound::Float64\nLower bounds. May be -Inf.\nhas_lower_bound::Bool\nBoolean indicating whether finite lower bound exists.\nupper_bound::Float64\nUpper bounds. May be Inf.\nhas_upper_bound::Bool\nBoolean indicating whether finite upper bound exists.\nis_fixed::Bool\nBoolean indicating variable is fixed to a finite value.\nbranch_on::EAGO.BRANCH_VARIABLE\nIs variable used for branching (unset in input model)\n\n\n\n\n\n","category":"type"},{"location":"Optimizer/optimizer/#EAGO.ExtensionType","page":"EAGO Optimizer","title":"EAGO.ExtensionType","text":"abstract type ExtensionType\n\nAn abstract type the subtypes of which are associated with functions method overloaded for for new extensions. An instance of the DefaultExt <:ExtensionType structure to the Optimizer in the ext_type field.\n\n\n\n\n\n","category":"type"},{"location":"Optimizer/optimizer/#EAGO.Log","page":"EAGO Optimizer","title":"EAGO.Log","text":"mutable struct Log\n\nA structure used to store information on the history of the solution procedure for generating convergence plots and other analysis.\n\ncurrent_lower_bound::Array{Float64,1}\nStorage for lower bound calculated for current node.\ncurrent_upper_bound::Array{Float64,1}\nStorage for upper bound calculated for current node.\npreprocessing_time::Array{Float64,1}\nStorage for preprocessing time of each iteration.\nlower_problem_time::Array{Float64,1}\nStorage for lower bounding time of each iteration.\nupper_problem_time::Array{Float64,1}\nStorage for upper bounding time of each iteration.\npostprocessing_time::Array{Float64,1}\nStorage for postprocessing time of each iteration.\npreprocessing_feas::Array{Bool,1}\nStorage for preprocessing feasibility of each iteration.\nlower_problem_feas::Array{Bool,1}\nStorage for lower bounding feasibility of each iteration.\nupper_problem_feas::Array{Bool,1}\nStorage for upper bounding feasibility of each iteration.\npostprocessing_feas::Array{Bool,1}\nStorage for postprocessing feasibility of each iteration.\nglobal_lower_bound::Array{Float64,1}\nStorage for best (global) lower bound at each iteration.\nglobal_upper_bound::Array{Float64,1}\nStorage for best (global) upper bound at each iteration.\nnode_count::Array{Int64,1}\nNumber of nodes at each iteration.\nrun_time::Array{Float64,1}\nRun time at each iteration.\n\n\n\n\n\n","category":"type"},{"location":"Optimizer/optimizer/#Internal-Problem-Representations","page":"EAGO Optimizer","title":"Internal Problem Representations","text":"","category":"section"},{"location":"Optimizer/optimizer/","page":"EAGO Optimizer","title":"EAGO Optimizer","text":"EAGO.InputProblem\nEAGO.ParsedProblem","category":"page"},{"location":"Optimizer/optimizer/#EAGO.InputProblem","page":"EAGO Optimizer","title":"EAGO.InputProblem","text":"mutable struct InputProblem\n\nA structure used to hold objectives and constraints added to EAGO model. The constraints generally aren't used for relaxations.\n\n\n\n\n\n","category":"type"},{"location":"Optimizer/optimizer/#EAGO.ParsedProblem","page":"EAGO Optimizer","title":"EAGO.ParsedProblem","text":"mutable struct ParsedProblem\n\nA structure used to expressions and problem descriptions EAGO uses to formulate relaxed problems.\n\n\n\n\n\n","category":"type"},{"location":"Optimizer/optimizer/#Extending-EAGO","page":"EAGO Optimizer","title":"Extending EAGO","text":"","category":"section"},{"location":"Optimizer/optimizer/","page":"EAGO Optimizer","title":"EAGO Optimizer","text":"Functionality has been included that allows for extension's to EAGO's optimizer to readily be defined. This can be done in two ways first defining a new structure which is a subtype of EAGO.ExtensionType and overloading methods associated with this new structure. An instance of this new structure is provided to the EAGO.Optimizer using the ext_type keyword. This results in EAGO now dispatch to the new methods rather than the generally defined methods for the parent type. For a complete example, the reader is directed to the interval bounding example and quasiconvex example. Alternatively, the user can overload the optimize_hook! for this subtype which will entirely circumvent the default global solution routine. Additional information can be stored in the ext field of EAGO. In order to allow for compatibility between packages the user is encouraged to append their extension name to the start of each variable name (e.g. newext_newdata).","category":"page"},{"location":"Optimizer/bnb_back/#EAGO's-Branch-and-Bound-Routine","page":"EAGO's Branch and Bound Routine","title":"EAGO's Branch and Bound Routine","text":"","category":"section"},{"location":"Optimizer/bnb_back/","page":"EAGO's Branch and Bound Routine","title":"EAGO's Branch and Bound Routine","text":"This component is meant to provide a flexible framework for implementing spatial branch-and-bound based optimization routines in Julia. All components of the branch-and-bound routine can be customized by the individual user: lower bounding problem, upper bounding problem.","category":"page"},{"location":"Optimizer/bnb_back/#Branch-and-Bound-Node-Storage","page":"EAGO's Branch and Bound Routine","title":"Branch and Bound Node Storage","text":"","category":"section"},{"location":"Optimizer/bnb_back/","page":"EAGO's Branch and Bound Routine","title":"EAGO's Branch and Bound Routine","text":"    EAGO.NodeBB","category":"page"},{"location":"Optimizer/bnb_back/#EAGO.NodeBB","page":"EAGO's Branch and Bound Routine","title":"EAGO.NodeBB","text":"struct NodeBB\n\nStores information associated with each node in Branch & Bound tree.\n\nlower_variable_bounds::Array{Float64,1}\nLower bounds of variable box.\nupper_variable_bounds::Array{Float64,1}\nUpper bounds of variable box.\nlower_bound::Float64\nLower bound of problem solution on nodeBB\nupper_bound::Float64\nUpper bound of problem solution on nodeBB\ndepth::Int64\nDepth of node in B&B tree.\nid::Int64\nUnique id for each node.\n\n\n\n\n\n","category":"type"},{"location":"Optimizer/bnb_back/#Customizable-subroutines","page":"EAGO's Branch and Bound Routine","title":"Customizable subroutines","text":"","category":"section"},{"location":"Optimizer/bnb_back/","page":"EAGO's Branch and Bound Routine","title":"EAGO's Branch and Bound Routine","text":"    EAGO.add_cut!(t::ExtensionType, x::Optimizer)\n    EAGO.branch_node!(t::ExtensionType, x::Optimizer)\n    EAGO.convergence_check(t::ExtensionType, x::Optimizer)\n    EAGO.cut_condition(t::ExtensionType, x::Optimizer)\n    EAGO.fathom!(t::ExtensionType, d::Optimizer)\n    EAGO.lower_problem!(t::ExtensionType, x::Optimizer)\n    EAGO.node_selection!(t::ExtensionType, x::Optimizer)\n    EAGO.optimize_hook!(t::ExtensionType, x::Optimizer)\n    EAGO.postprocess!(t::ExtensionType, x::Optimizer)\n    EAGO.preprocess!(t::ExtensionType, x::Optimizer)\n    EAGO.repeat_check(t::ExtensionType, x::Optimizer)\n    EAGO.single_storage!(t::ExtensionType, x::Optimizer)\n    EAGO.termination_check(t::ExtensionType, x::Optimizer)\n    EAGO.upper_problem!(t::ExtensionType, x::Optimizer)","category":"page"},{"location":"Optimizer/bnb_back/#EAGO.add_cut!-Tuple{ExtensionType,Optimizer}","page":"EAGO's Branch and Bound Routine","title":"EAGO.add_cut!","text":"add_cut!(t, m)\n\n\nAdds a cut for each constraint and the objective function to the subproblem.\n\n\n\n\n\n","category":"method"},{"location":"Optimizer/bnb_back/#EAGO.branch_node!-Tuple{ExtensionType,Optimizer}","page":"EAGO's Branch and Bound Routine","title":"EAGO.branch_node!","text":"branch_node!(t, m)\n\n\nCreates two nodes from current_node using information available the x and stores them to the stack. By default, relative width bisection is perfomed at a point branch_pnt which is a convex combination (parameter: branch_cvx_factor) of the solution to the relaxation and the midpoint of the node. If this solution lies within branch_offset/width of a bound then the branch point is moved to a distance of branch_offset/width from the bound.\n\n\n\n\n\n","category":"method"},{"location":"Optimizer/bnb_back/#EAGO.convergence_check-Tuple{ExtensionType,Optimizer}","page":"EAGO's Branch and Bound Routine","title":"EAGO.convergence_check","text":"convergence_check(t, m)\n\n\nChecks for convergence of algorithm with respect to absolute and/or relative tolerances.\n\n\n\n\n\n","category":"method"},{"location":"Optimizer/bnb_back/#EAGO.cut_condition-Tuple{ExtensionType,Optimizer}","page":"EAGO's Branch and Bound Routine","title":"EAGO.cut_condition","text":"cut_condition(t, m)\n\n\nChecks if a cut should be added and computes a new reference point to add the cut at. If no cut should be added the constraints not modified in place are deleted from the relaxed optimizer and the solution is compared with the interval lower bound. The best lower bound is then used.\n\n\n\n\n\n","category":"method"},{"location":"Optimizer/bnb_back/#EAGO.fathom!-Tuple{ExtensionType,Optimizer}","page":"EAGO's Branch and Bound Routine","title":"EAGO.fathom!","text":"fathom!(t, m)\n\n\nSelects and deletes nodes from stack with lower bounds greater than global upper bound.\n\n\n\n\n\n","category":"method"},{"location":"Optimizer/bnb_back/#EAGO.lower_problem!-Tuple{ExtensionType,Optimizer}","page":"EAGO's Branch and Bound Routine","title":"EAGO.lower_problem!","text":"lower_problem!(t, m)\n\n\nConstructs and solves the relaxation using the default EAGO relaxation scheme and optimizer on node y.\n\n\n\n\n\n","category":"method"},{"location":"Optimizer/bnb_back/#EAGO.node_selection!-Tuple{ExtensionType,Optimizer}","page":"EAGO's Branch and Bound Routine","title":"EAGO.node_selection!","text":"node_selection!(t, m)\n\n\nSelects node with the lowest lower bound in stack.\n\n\n\n\n\n","category":"method"},{"location":"Optimizer/bnb_back/#EAGO.optimize_hook!-Tuple{ExtensionType,Optimizer}","page":"EAGO's Branch and Bound Routine","title":"EAGO.optimize_hook!","text":"optimize_hook!(t, m)\n\n\nProvides a hook for extensions to EAGO as opposed to standard global, local, or linear solvers.\n\n\n\n\n\n","category":"method"},{"location":"Optimizer/bnb_back/#EAGO.postprocess!-Tuple{ExtensionType,Optimizer}","page":"EAGO's Branch and Bound Routine","title":"EAGO.postprocess!","text":"postprocess!(t, m)\n\n\nDefault postprocess perfoms duality-based bound tightening on the y.\n\n\n\n\n\n","category":"method"},{"location":"Optimizer/bnb_back/#EAGO.preprocess!-Tuple{ExtensionType,Optimizer}","page":"EAGO's Branch and Bound Routine","title":"EAGO.preprocess!","text":"preprocess!(t, m)\n\n\nRuns interval, linear, quadratic contractor methods followed by obbt and a constraint programming walk up to tolerances specified in EAGO.Optimizer object.\n\n\n\n\n\n","category":"method"},{"location":"Optimizer/bnb_back/#EAGO.repeat_check-Tuple{ExtensionType,Optimizer}","page":"EAGO's Branch and Bound Routine","title":"EAGO.repeat_check","text":"repeat_check(t, m)\n\n\nChecks to see if current node should be reprocessed.\n\n\n\n\n\n","category":"method"},{"location":"Optimizer/bnb_back/#EAGO.single_storage!-Tuple{ExtensionType,Optimizer}","page":"EAGO's Branch and Bound Routine","title":"EAGO.single_storage!","text":"single_storage!(t, m)\n\n\nStores the current node to the stack after updating lower/upper bounds.\n\n\n\n\n\n","category":"method"},{"location":"Optimizer/bnb_back/#EAGO.termination_check-Tuple{ExtensionType,Optimizer}","page":"EAGO's Branch and Bound Routine","title":"EAGO.termination_check","text":"termination_check(t, m)\n\n\nChecks for termination of algorithm due to satisfying absolute or relative tolerance, infeasibility, or a specified limit, returns a boolean valued true if algorithm should continue.\n\n\n\n\n\n","category":"method"},{"location":"Optimizer/bnb_back/#EAGO.upper_problem!-Tuple{ExtensionType,Optimizer}","page":"EAGO's Branch and Bound Routine","title":"EAGO.upper_problem!","text":"upper_problem!(t, m)\n\n\nDefault upper bounding problem which simply calls solve_local_nlp! to solve the nlp locally.\n\n\n\n\n\n","category":"method"},{"location":"Optimizer/bnb_back/#Internal-Subroutines","page":"EAGO's Branch and Bound Routine","title":"Internal Subroutines","text":"","category":"section"},{"location":"Optimizer/bnb_back/","page":"EAGO's Branch and Bound Routine","title":"EAGO's Branch and Bound Routine","text":"    EAGO.cut_update!(x::Optimizer)\n    EAGO.interval_bound\n    EAGO.lower_interval_bound\n    EAGO.is_globally_optimal(t::MOI.TerminationStatusCode, r::MOI.ResultStatusCode)\n    EAGO.is_feasible_solution(t::MOI.TerminationStatusCode, r::MOI.ResultStatusCode)\n    EAGO.log_iteration!(x::Optimizer)\n    EAGO.same_box(x::NodeBB,y::NodeBB, atol::Float64)\n    EAGO.solve_local_nlp!(x::Optimizer)\n    EAGO.set_dual!(x::Optimizer)\n    EAGO.update_relaxed_problem_box!","category":"page"},{"location":"Optimizer/bnb_back/#EAGO.cut_update!-Tuple{Optimizer}","page":"EAGO's Branch and Bound Routine","title":"EAGO.cut_update!","text":"cut_update!(m)\n\n\nUpdates the internal storage in the optimizer after a valid feasible cut is added.\n\n\n\n\n\n","category":"method"},{"location":"Optimizer/bnb_back/#EAGO.interval_bound","page":"EAGO's Branch and Bound Routine","title":"EAGO.interval_bound","text":"Computes a tuple representing the lower and upper interval bounds for a AbstractEAGOConstraint representing an equality constraint.\n\n\n\n\n\n","category":"function"},{"location":"Optimizer/bnb_back/#EAGO.lower_interval_bound","page":"EAGO's Branch and Bound Routine","title":"EAGO.lower_interval_bound","text":"Computes the lower interval bound for AbstractEAGOConstraint representing an inequality constraint.\n\n\n\n\n\n","category":"function"},{"location":"Optimizer/bnb_back/#EAGO.is_globally_optimal-Tuple{MathOptInterface.TerminationStatusCode,MathOptInterface.ResultStatusCode}","page":"EAGO's Branch and Bound Routine","title":"EAGO.is_globally_optimal","text":"is_globally_optimal(t, r)\n\n\nTakes an MOI.TerminationStatusCode and a MOI.ResultStatusCode and returns the tuple (valid_result::Bool, feasible::Bool). The value valid_result is true if the pair of codes prove that either the subproblem solution was solved to global optimality or the subproblem solution is infeasible. The value of feasible is true if the problem is feasible and false if the problem is infeasible.\n\n\n\n\n\n","category":"method"},{"location":"Optimizer/bnb_back/#EAGO.is_feasible_solution-Tuple{MathOptInterface.TerminationStatusCode,MathOptInterface.ResultStatusCode}","page":"EAGO's Branch and Bound Routine","title":"EAGO.is_feasible_solution","text":"is_feasible_solution(t, r)\n\n\nTakes an MOI.TerminationStatusCode and a MOI.ResultStatusCode and returns true if this corresponds to a solution that is proven to be feasible. Returns false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"Optimizer/bnb_back/#EAGO.log_iteration!-Tuple{Optimizer}","page":"EAGO's Branch and Bound Routine","title":"EAGO.log_iteration!","text":"log_iteration!(x::Optimizer)\n\nIf 'loggingon' is true, the 'globallowerbound', 'globalupperbound', 'runtime', and 'nodecount' are stored every 'loginterval'. If 'logsubprobleminfo' then the lower bound, feasibility and run times of the subproblems are logged every 'log_interval'.\n\n\n\n\n\n","category":"method"},{"location":"Optimizer/bnb_back/#EAGO.same_box-Tuple{NodeBB,NodeBB,Float64}","page":"EAGO's Branch and Bound Routine","title":"EAGO.same_box","text":"same_box\n\nChecks that node x and y have equal domains withing a tolerance of atol.\n\n\n\n\n\n","category":"method"},{"location":"Optimizer/bnb_back/#EAGO.solve_local_nlp!-Tuple{Optimizer}","page":"EAGO's Branch and Bound Routine","title":"EAGO.solve_local_nlp!","text":"Constructs and solves the problem locally on on node y updated the upper solution informaton in the optimizer.\n\n\n\n\n\n","category":"method"},{"location":"Optimizer/bnb_back/#EAGO.set_dual!-Tuple{Optimizer}","page":"EAGO's Branch and Bound Routine","title":"EAGO.set_dual!","text":"set_dual!(m)\n\n\nRetrieves the lower and upper duals for variable bounds from the relaxed_optimizer and sets the appropriate values in the _lower_lvd and _lower_uvd storage fields.\n\n\n\n\n\n","category":"method"},{"location":"Optimizer/bnb_back/#EAGO.update_relaxed_problem_box!","page":"EAGO's Branch and Bound Routine","title":"EAGO.update_relaxed_problem_box!","text":"update_relaxed_problem_box!(m)\n\n\nUpdates the relaxed constraint by setting the constraint set of v == x*,xLi <= xi, andxi <= xUi` for each such constraint added to the relaxed optimizer.\n\n\n\n\n\n","category":"function"},{"location":"Optimizer/bnb_back/#Functions-for-generating-console-output","page":"EAGO's Branch and Bound Routine","title":"Functions for generating console output","text":"","category":"section"},{"location":"Optimizer/bnb_back/","page":"EAGO's Branch and Bound Routine","title":"EAGO's Branch and Bound Routine","text":"    EAGO.print_iteration!\n    EAGO.print_node!\n    EAGO.print_results!\n    EAGO.print_solution!","category":"page"},{"location":"Optimizer/bnb_back/#EAGO.print_iteration!","page":"EAGO's Branch and Bound Routine","title":"EAGO.print_iteration!","text":"print_iteration!\n\nPrints the iteration information based on verbosity. The header is displayed every header_interval, the iteration info is displayed every iteration_interval.\n\n\n\n\n\n","category":"function"},{"location":"Optimizer/bnb_back/#EAGO.print_node!","page":"EAGO's Branch and Bound Routine","title":"EAGO.print_node!","text":"print_node!\n\nPrints node information for the B&B problem. Node id, bound, and interval box.\n\n\n\n\n\n","category":"function"},{"location":"Optimizer/bnb_back/#EAGO.print_results!","page":"EAGO's Branch and Bound Routine","title":"EAGO.print_results!","text":"print_results!\n\nPrints the results of a single bounding problem.\n\n\n\n\n\n","category":"function"},{"location":"Optimizer/bnb_back/#EAGO.print_solution!","page":"EAGO's Branch and Bound Routine","title":"EAGO.print_solution!","text":"print_solution!\n\nPrints solution information for the B&B problem. Displays first node found, solution value, solution, and time spent solving subproblems.\n\n\n\n\n\n","category":"function"},{"location":"Optimizer/bnb_back/#Interval-Representations-of-Expressions","page":"EAGO's Branch and Bound Routine","title":"Interval Representations of Expressions","text":"","category":"section"},{"location":"Optimizer/bnb_back/","page":"EAGO's Branch and Bound Routine","title":"EAGO's Branch and Bound Routine","text":"    EAGO.AbstractEAGOConstraint\n    EAGO.AffineFunctionEq\n    EAGO.AffineFunctionIneq\n    EAGO.BufferedQuadraticIneq\n    EAGO.BufferedQuadraticEq\n    EAGO.NonlinearExpression\n    EAGO.BufferedNonlinearFunction","category":"page"},{"location":"Optimizer/bnb_back/#EAGO.AbstractEAGOConstraint","page":"EAGO's Branch and Bound Routine","title":"EAGO.AbstractEAGOConstraint","text":"abstract type AbstractEAGOConstraint\n\nAn abstract super-type used for representing constraints built by EAGO's backend.\n\n\n\n\n\n","category":"type"},{"location":"Optimizer/bnb_back/#EAGO.AffineFunctionEq","page":"EAGO's Branch and Bound Routine","title":"EAGO.AffineFunctionEq","text":"mutable struct AffineFunctionEq <: EAGO.AbstractEAGOConstraint\n\nCurrent only used for bound tightening. Stores a representation of an affine equality.\n\n\n\n\n\n","category":"type"},{"location":"Optimizer/bnb_back/#EAGO.AffineFunctionIneq","page":"EAGO's Branch and Bound Routine","title":"EAGO.AffineFunctionIneq","text":"mutable struct AffineFunctionIneq <: EAGO.AbstractEAGOConstraint\n\nCurrent only used for bound tightening. Stores a representation of an affine inequality.\n\n\n\n\n\n","category":"type"},{"location":"Optimizer/bnb_back/#EAGO.BufferedQuadraticIneq","page":"EAGO's Branch and Bound Routine","title":"EAGO.BufferedQuadraticIneq","text":"mutable struct BufferedQuadraticIneq <: EAGO.AbstractEAGOConstraint\n\nStores a general quadratic inequality constraint with a buffer.\n\n\n\n\n\n","category":"type"},{"location":"Optimizer/bnb_back/#EAGO.BufferedQuadraticEq","page":"EAGO's Branch and Bound Routine","title":"EAGO.BufferedQuadraticEq","text":"mutable struct BufferedQuadraticEq <: EAGO.AbstractEAGOConstraint\n\nStores a general quadratic equality constraint with a buffer.\n\n\n\n\n\n","category":"type"},{"location":"Optimizer/bnb_back/#EAGO.NonlinearExpression","page":"EAGO's Branch and Bound Routine","title":"EAGO.NonlinearExpression","text":"mutable struct NonlinearExpression{V} <: EAGO.AbstractEAGOConstraint\n\nStores a general quadratic function with a buffer.\n\n\n\n\n\n","category":"type"},{"location":"Optimizer/bnb_back/#EAGO.BufferedNonlinearFunction","page":"EAGO's Branch and Bound Routine","title":"EAGO.BufferedNonlinearFunction","text":"mutable struct BufferedNonlinearFunction{V} <: EAGO.AbstractEAGOConstraint\n\nStores a general nonlinear function with a buffer represented by the sum of a tape and a scalar affine function.\n\n\n\n\n\n","category":"type"},{"location":"Optimizer/domain_reduction/#Domain-Reduction","page":"Domain Reduction","title":"Domain Reduction","text":"","category":"section"},{"location":"Optimizer/domain_reduction/#Duality-Based-Bound-Tightening","page":"Domain Reduction","title":"Duality-Based Bound Tightening","text":"","category":"section"},{"location":"Optimizer/domain_reduction/","page":"Domain Reduction","title":"Domain Reduction","text":"Variable bound tightening based on the duality multipliers are supported.","category":"page"},{"location":"Optimizer/domain_reduction/","page":"Domain Reduction","title":"Domain Reduction","text":"variable_dbbt!","category":"page"},{"location":"Optimizer/domain_reduction/#EAGO.variable_dbbt!","page":"Domain Reduction","title":"EAGO.variable_dbbt!","text":"variable_dbbt!\n\nTightens the bounds of the _current_node using the current global upper bound and the duality information obtained from the relaxation.\n\n\n\n\n\n","category":"function"},{"location":"Optimizer/domain_reduction/#Special-Forms","page":"Domain Reduction","title":"Special Forms","text":"","category":"section"},{"location":"Optimizer/domain_reduction/","page":"Domain Reduction","title":"Domain Reduction","text":"Bound tightening for linear forms, univariate quadratic forms, and bivariate quadratic forms are also supported.","category":"page"},{"location":"Optimizer/domain_reduction/","page":"Domain Reduction","title":"Domain Reduction","text":"EAGO.fbbt!","category":"page"},{"location":"Optimizer/domain_reduction/#EAGO.fbbt!","page":"Domain Reduction","title":"EAGO.fbbt!","text":"fbbt!\n\nPerforms feasibility-based bound tightening on a back-end constraint and returns true if it is feasible or false if it is infeasible.\n\n\n\n\n\n","category":"function"},{"location":"Optimizer/domain_reduction/#Constraint-Propagation","page":"Domain Reduction","title":"Constraint Propagation","text":"","category":"section"},{"location":"Optimizer/domain_reduction/","page":"Domain Reduction","title":"Domain Reduction","text":"EAGO contains a constraint propagation architecture that supported forward and reverse evaluation of set-valued functions on the directed acyclic graph (DAG). The interval contractor and reverse McCormick relaxation-based contractors are currently available.","category":"page"},{"location":"Optimizer/domain_reduction/","page":"Domain Reduction","title":"Domain Reduction","text":"EAGO.set_constraint_propagation_fbbt!","category":"page"},{"location":"Optimizer/domain_reduction/#EAGO.set_constraint_propagation_fbbt!","page":"Domain Reduction","title":"EAGO.set_constraint_propagation_fbbt!","text":"Performs bound tightening based on forward/reverse interval and/or McCormick passes. This routine resets the current node with new interval bounds.\n\n\n\n\n\n","category":"function"},{"location":"Optimizer/domain_reduction/#Optimization-Based-Bound-Tightening","page":"Domain Reduction","title":"Optimization-Based Bound Tightening","text":"","category":"section"},{"location":"Optimizer/domain_reduction/","page":"Domain Reduction","title":"Domain Reduction","text":"EAGO makes use of an optimization-based bound tightening scheme using filtering and greedy ordering as detailed in: Gleixner, A.M., Berthold, T., Müller, B. et al. J Glob Optim (2017) 67: 731. https://doi.org/10.1007/s10898-016-0450-4.","category":"page"},{"location":"Optimizer/domain_reduction/","page":"Domain Reduction","title":"Domain Reduction","text":"EAGO.obbt!\ntrivial_filtering!\naggressive_filtering!\nbool_indx_diff","category":"page"},{"location":"Optimizer/domain_reduction/#EAGO.obbt!","page":"Domain Reduction","title":"EAGO.obbt!","text":"obbt!\n\nPerforms OBBT with filtering and greedy ordering as detailed in: Gleixner, A.M., Berthold, T., Müller, B. et al. J Glob Optim (2017) 67: 731. https://doi.org/10.1007/s10898-016-0450-4\n\n\n\n\n\n","category":"function"},{"location":"Optimizer/domain_reduction/#EAGO.trivial_filtering!","page":"Domain Reduction","title":"EAGO.trivial_filtering!","text":"trivial_filtering!\n\nExcludes OBBT on variable indices that are tight for the solution of the relaxation.\n\n\n\n\n\n","category":"function"},{"location":"Optimizer/domain_reduction/#EAGO.aggressive_filtering!","page":"Domain Reduction","title":"EAGO.aggressive_filtering!","text":"aggressive_filtering!\n\nExcludes OBBT on variable indices after a search in a filtering direction.\n\n\n\n\n\n","category":"function"},{"location":"Optimizer/domain_reduction/#EAGO.bool_indx_diff","page":"Domain Reduction","title":"EAGO.bool_indx_diff","text":"boolindxdiff\n\nUtility function used to set vector of booleans z to x & ~y. Avoids the generation of conversion of the BitArray created by broadcasting logical operators.\n\n\n\n\n\n","category":"function"},{"location":"Optimizer/relax_back/#Relaxation-Backend","page":"Relaxation Backend","title":"Relaxation Backend","text":"","category":"section"},{"location":"Optimizer/relax_back/#Nonlinear-Evaluation","page":"Relaxation Backend","title":"Nonlinear Evaluation","text":"","category":"section"},{"location":"Optimizer/relax_back/","page":"Relaxation Backend","title":"Relaxation Backend","text":"EAGO makes use of a specialized tape structure for each function in order to compute valid composite bounds and relaxations. The details of this are included below:","category":"page"},{"location":"Optimizer/relax_back/#Forward-Operator-Updates","page":"Relaxation Backend","title":"Forward Operator Updates","text":"","category":"section"},{"location":"Optimizer/relax_back/#Main-routine","page":"Relaxation Backend","title":"Main routine","text":"","category":"section"},{"location":"Optimizer/relax_back/","page":"Relaxation Backend","title":"Relaxation Backend","text":"EAGO.forward_pass_kernel!","category":"page"},{"location":"Optimizer/relax_back/#EAGO.forward_pass_kernel!","page":"Relaxation Backend","title":"EAGO.forward_pass_kernel!","text":"forwardpasskernel!\n\nPerforms a forward pass using the tape information passed as arguments. Each variety of node calls an associated forward_xxx function where xxx is a descriptor.\n\n\n\n\n\n","category":"function"},{"location":"Optimizer/relax_back/#Subroutines-to-evaluation-expression","page":"Relaxation Backend","title":"Subroutines to evaluation expression","text":"","category":"section"},{"location":"Optimizer/relax_back/","page":"Relaxation Backend","title":"Relaxation Backend","text":" EAGO.forward_plus_narity!\n EAGO.forward_plus_binary!\n EAGO.forward_minus!\n EAGO.forward_multiply_binary!\n EAGO.forward_multiply_narity!\n EAGO.forward_divide!\n EAGO.forward_power!\n EAGO.forward_univariate_user!\n EAGO.forward_univariate_number!\n EAGO.forward_univariate_tiepnt_1!\n EAGO.forward_univariate_tiepnt_2!\n EAGO.forward_univariate_other!\n EAGO.forward_user_multivariate!\n EAGO.forward_get_subexpression!","category":"page"},{"location":"Optimizer/relax_back/#EAGO.forward_plus_narity!","page":"Relaxation Backend","title":"EAGO.forward_plus_narity!","text":"forwardplusnarity!\n\nUpdates storage tapes with forward evalution of node representing n = +(x, y, z,...).\n\n\n\n\n\n","category":"function"},{"location":"Optimizer/relax_back/#EAGO.forward_plus_binary!","page":"Relaxation Backend","title":"EAGO.forward_plus_binary!","text":"forwardplusbinary!\n\nUpdates storage tapes with forward evalution of node representing n = x + y.\n\n\n\n\n\n","category":"function"},{"location":"Optimizer/relax_back/#EAGO.forward_minus!","page":"Relaxation Backend","title":"EAGO.forward_minus!","text":"forward_minus!\n\nUpdates storage tapes with forward evalution for node representing n = x-y.\n\n\n\n\n\n","category":"function"},{"location":"Optimizer/relax_back/#EAGO.forward_multiply_binary!","page":"Relaxation Backend","title":"EAGO.forward_multiply_binary!","text":"forwardmultiplybinary!\n\nUpdates storage tapes with forward evalution for node representing n = x*y.\n\n\n\n\n\n","category":"function"},{"location":"Optimizer/relax_back/#EAGO.forward_multiply_narity!","page":"Relaxation Backend","title":"EAGO.forward_multiply_narity!","text":"forwardmultiplynarity!\n\nUpdates storage tapes with forward evalution of node representing n = *(x, y, z,...).\n\n\n\n\n\n","category":"function"},{"location":"Optimizer/relax_back/#EAGO.forward_divide!","page":"Relaxation Backend","title":"EAGO.forward_divide!","text":"forward_divide!\n\nUpdates storage tapes with forward evalution for node representing n = x/y.\n\n\n\n\n\n","category":"function"},{"location":"Optimizer/relax_back/#EAGO.forward_power!","page":"Relaxation Backend","title":"EAGO.forward_power!","text":"forward_power!\n\nUpdates storage tapes with forward evalution for node representing n = x^y.\n\n\n\n\n\n","category":"function"},{"location":"Optimizer/relax_back/#EAGO.forward_univariate_user!","page":"Relaxation Backend","title":"EAGO.forward_univariate_user!","text":"forwardunivariateuser!\n\nUpdates storage tapes with forward evalution for node representing n = user_f(x).\n\n\n\n\n\n","category":"function"},{"location":"Optimizer/relax_back/#EAGO.forward_univariate_number!","page":"Relaxation Backend","title":"EAGO.forward_univariate_number!","text":"forwardunivariatenumber!\n\nUpdates storage tapes with forward evalution for node representing n = f(c) where f is standard function and c is a number.\n\n\n\n\n\n","category":"function"},{"location":"Optimizer/relax_back/#EAGO.forward_univariate_tiepnt_1!","page":"Relaxation Backend","title":"EAGO.forward_univariate_tiepnt_1!","text":"forwardunivariatetiepnt_1!\n\nUpdates storage tapes with forward evalution for node representing n = f(x) where f is standard function that requires a single tiepoint calculation per convex/concave relaxation (e.g. tan).\n\n\n\n\n\n","category":"function"},{"location":"Optimizer/relax_back/#EAGO.forward_univariate_tiepnt_2!","page":"Relaxation Backend","title":"EAGO.forward_univariate_tiepnt_2!","text":"forwardunivariatetiepnt_2!\n\nUpdates storage tapes with forward evalution for node representing n = f(x) where f is standard function that requires a two tiepoint calculations per convex/concave relaxation (e.g. sin).\n\n\n\n\n\n","category":"function"},{"location":"Optimizer/relax_back/#EAGO.forward_univariate_other!","page":"Relaxation Backend","title":"EAGO.forward_univariate_other!","text":"forwardunivariateother!\n\nUpdates storage tapes with forward evalution for node representing n = f(x) where f is a standard function that does not require a tiepoint evaluation (e.g. exp).\n\n\n\n\n\n","category":"function"},{"location":"Optimizer/relax_back/#EAGO.forward_user_multivariate!","page":"Relaxation Backend","title":"EAGO.forward_user_multivariate!","text":"forwardusermultivariate!\n\nUpdates storage tapes with forward evalution for node representing n = user_f(x, y...).\n\n\n\n\n\n","category":"function"},{"location":"Optimizer/relax_back/#EAGO.forward_get_subexpression!","page":"Relaxation Backend","title":"EAGO.forward_get_subexpression!","text":"forwardgetsubexpression!\n\nUnpacks the MC{N1,T} in the subexpression to a MC{N2,T} where N1 is the sparsity of the subexpression and N2 is the sparsity of the function tape. Note that the sparsity of the subexpression is less than the sparsity of the function itself. This limits the storage required by tapes but prevents reverse mode subgradient propagation through expressions [This may be subject to change in the future once the reverse mode propagation becomes more robust].\n\n\n\n\n\n","category":"function"},{"location":"Optimizer/relax_back/#Reverse-Operator-Updates","page":"Relaxation Backend","title":"Reverse Operator Updates","text":"","category":"section"},{"location":"Optimizer/relax_back/#Main-routine-2","page":"Relaxation Backend","title":"Main routine","text":"","category":"section"},{"location":"Optimizer/relax_back/","page":"Relaxation Backend","title":"Relaxation Backend","text":"EAGO.reverse_pass!\nEAGO.reverse_pass_kernel!","category":"page"},{"location":"Optimizer/relax_back/#EAGO.reverse_pass!","page":"Relaxation Backend","title":"EAGO.reverse_pass!","text":"reverse_pass!\n\nA reverse_pass! on a BufferedNonlinear structure d intersects the existing value of the d with constraint bounds then reverse propagates a set-valued operator (by default McCormick operator) along the computational tape. The tapes are updated in place and boolean value is returned indicating whether the reverse propagation yeilded a infeasible point (true = still feasible, false is proved infeasible).\n\n\n\n\n\n","category":"function"},{"location":"Optimizer/relax_back/#EAGO.reverse_pass_kernel!","page":"Relaxation Backend","title":"EAGO.reverse_pass_kernel!","text":"Performs a reverse McCormick/interval pass. If a NaN value is computed for the McCormick relaxation then the routine defaults to the interval value instead.\n\nThere is a tacit assumption here that an abstract tree structure is used for propagation. If a cse structure is eventually used then each reverse_xxx function will need to keep track of each variables state.\n\n\n\n\n\n","category":"function"},{"location":"Optimizer/relax_back/#Subroutines-to-evaluation-expression-2","page":"Relaxation Backend","title":"Subroutines to evaluation expression","text":"","category":"section"},{"location":"Optimizer/relax_back/","page":"Relaxation Backend","title":"Relaxation Backend","text":"This list is not yet complete future documentation to be added.","category":"page"},{"location":"Optimizer/relax_back/","page":"Relaxation Backend","title":"Relaxation Backend","text":"EAGO.reverse_plus_binary!\nEAGO.reverse_plus_narity!\nEAGO.reverse_multiply_binary!\nEAGO.reverse_multiply_narity!","category":"page"},{"location":"Optimizer/relax_back/#EAGO.reverse_plus_binary!","page":"Relaxation Backend","title":"EAGO.reverse_plus_binary!","text":"reverseplusbinary!\n\nUpdates storage tapes with reverse evalution of node representing n = x + y which updates x & y.\n\n\n\n\n\n","category":"function"},{"location":"Optimizer/relax_back/#EAGO.reverse_plus_narity!","page":"Relaxation Backend","title":"EAGO.reverse_plus_narity!","text":"reverseplusnarity!\n\nUpdates storage tapes with reverse evalution of node representing n = +(x,y,z...) which updates x, y, z and so on.\n\n\n\n\n\n","category":"function"},{"location":"Optimizer/relax_back/#EAGO.reverse_multiply_binary!","page":"Relaxation Backend","title":"EAGO.reverse_multiply_binary!","text":"reversemultiplybinary!\n\nUpdates storage tapes with reverse evalution of node representing n = x * y which updates x & y.\n\n\n\n\n\n","category":"function"},{"location":"Optimizer/relax_back/#EAGO.reverse_multiply_narity!","page":"Relaxation Backend","title":"EAGO.reverse_multiply_narity!","text":"reversemultiplynarity!\n\nUpdates storage tapes with reverse evalution of node representing n = *(x,y,z...) which updates x, y, z and so on.\n\n\n\n\n\n","category":"function"},{"location":"Optimizer/relax_back/#Other-routines","page":"Relaxation Backend","title":"Other routines","text":"","category":"section"},{"location":"Optimizer/relax_back/","page":"Relaxation Backend","title":"Relaxation Backend","text":"EAGO.set_value_post\nEAGO.overwrite_or_intersect","category":"page"},{"location":"Optimizer/relax_back/#EAGO.set_value_post","page":"Relaxation Backend","title":"EAGO.set_value_post","text":"setvaluepost\n\nPost process set_value operator. By default, performs the affine interval cut on a MC structure.\n\n\n\n\n\n","category":"function"},{"location":"Optimizer/relax_back/#EAGO.overwrite_or_intersect","page":"Relaxation Backend","title":"EAGO.overwrite_or_intersect","text":"overwriteorintersect\n\nIntersects the new set valued operator with the prior and performs affine bound tightening\n\nFirst forward pass: is_post should be set by user option, is_intersect should be false so that the tape overwrites existing values, and the interval_intersect flag could be set to either value.\nForward CP pass (assumes same reference point): is_post should be set by user option, is_intersect should be true so that the tape intersects with  existing values, and the interval_intersect flag should be false.\nForward CP pass (assumes same reference point): is_post should be set by user option, is_intersect should be true so that the tape intersects with existing values, and the interval_intersect flag should be false.\nSubsequent forward passes at new points: ispostshould be set by user option,isintersectshould be true so that the tape intersects with existing values, and theinterval_intersectflag should betrue` as predetermined interval bounds are valid but  the prior values may correspond to different points of evaluation.\n\n\n\n\n\n","category":"function"},{"location":"SemiInfinite/semiinfinite/#Solving-Semi-Infinite-Programming","page":"Semi-Infinite Programming","title":"Solving Semi-Infinite Programming","text":"","category":"section"},{"location":"SemiInfinite/semiinfinite/","page":"Semi-Infinite Programming","title":"Semi-Infinite Programming","text":"Matthew Wilhelm   Department of Chemical and Biomolecular Engineering, University of Connecticut","category":"page"},{"location":"SemiInfinite/semiinfinite/#Using-EAGO-to-solve-a-SIP","page":"Semi-Infinite Programming","title":"Using EAGO to solve a SIP","text":"","category":"section"},{"location":"SemiInfinite/semiinfinite/","page":"Semi-Infinite Programming","title":"Semi-Infinite Programming","text":"Semi-infinite programming remains an active area of research. In general, the solution of semi-infinite programs with nonconvex semi-infinite constraints of the below form are extremely challenging:","category":"page"},{"location":"SemiInfinite/semiinfinite/","page":"Semi-Infinite Programming","title":"Semi-Infinite Programming","text":"(Image: SipProbForm)","category":"page"},{"location":"SemiInfinite/semiinfinite/","page":"Semi-Infinite Programming","title":"Semi-Infinite Programming","text":"EAGO implements three different algorithm detailed in [1,2] to determine a globally optimal solution to problems of the above form. This accomplished using the sip_solve function which returns the optimal value, the solution, and a boolean feasibility value. To illustrate the functions use, a simple example is presented here which solves the below problem:","category":"page"},{"location":"SemiInfinite/semiinfinite/","page":"Semi-Infinite Programming","title":"Semi-Infinite Programming","text":"(Image: SipForm)","category":"page"},{"location":"SemiInfinite/semiinfinite/","page":"Semi-Infinite Programming","title":"Semi-Infinite Programming","text":"using EAGO, JuMP\n\n# Define semi-infinite program\nf(x) = (1/3)*x[1]^2 + x[2]^2 + x[1]/2\ngSIP(x,p) = (1.0 - (x[1]^2)*(p[1]^2))^2 - x[1]*p[1]^2 - x[2]^2 + x[2]\n\nx_l = Float64[-1000.0, -1000.0]\nx_u = Float64[1000.0, 1000.0]\np_l = Float64[0.0]\np_u = Float64[1.0]\n\nsip_result = sip_solve(SIPRes(), x_l, x_u, p_l, p_u, f, Any[gSIP], abs_tolerance = 1E-3)\n\nprintln(\"The global minimum of the semi-infinite program is between: $(sip_result.lower_bound) and $(sip_result.upper_bound).\")\nprintln(\"The global minimum is attained at: x = $(sip_result.xsol).\")\nprintln(\"Is the problem feasible? $(sip_result.feasibility).\")","category":"page"},{"location":"SemiInfinite/semiinfinite/#Semi-infinite-solver","page":"Semi-Infinite Programming","title":"Semi-infinite solver","text":"","category":"section"},{"location":"SemiInfinite/semiinfinite/","page":"Semi-Infinite Programming","title":"Semi-Infinite Programming","text":"    SIPProblem\n    SIPResult\n    SIPRes\n    SIPResRev\n    SIPHybrid\n    get_sip_optimizer\n    build_model\n    sip_llp!\n    sip_bnd!\n    sip_res!\n    sip_solve","category":"page"},{"location":"SemiInfinite/semiinfinite/#EAGO.SIPProblem","page":"Semi-Infinite Programming","title":"EAGO.SIPProblem","text":"  SIPProblem\n\nStructure storing problem information for the solution routine.\n\n\n\n\n\n","category":"type"},{"location":"SemiInfinite/semiinfinite/#EAGO.SIPResult","page":"Semi-Infinite Programming","title":"EAGO.SIPResult","text":"SIPResult\n\nStructure storing the results of the SIPres algorithm.\n\n\n\n\n\n","category":"type"},{"location":"SemiInfinite/semiinfinite/#EAGO.SIPRes","page":"Semi-Infinite Programming","title":"EAGO.SIPRes","text":"SIPRes\n\nSpecifies that the SIPRes algorithm which implements Algorithm #1 of Djelassi, Hatim, and Alexander Mitsos. \"A hybrid discretization algorithm with guaranteed feasibility for the global solution of semi-infinite programs.\" Journal of Global Optimization 68.2 (2017): 227-253 should be used.\n\n\n\n\n\n","category":"type"},{"location":"SemiInfinite/semiinfinite/#EAGO.SIPResRev","page":"Semi-Infinite Programming","title":"EAGO.SIPResRev","text":"SIPResRev\n\nSpecifies that the SIPResRev algorithm which implements Algorithm #1 of Djelassi, Hatim, and Alexander Mitsos. \"A hybrid discretization algorithm with guaranteed feasibility for the global solution of semi-infinite programs.\" Journal of Global Optimization 68.2 (2017): 227-253 should be used.\n\n\n\n\n\n","category":"type"},{"location":"SemiInfinite/semiinfinite/#EAGO.SIPHybrid","page":"Semi-Infinite Programming","title":"EAGO.SIPHybrid","text":"SIPHybrid\n\nSpecifies that the SIPHybrid algorithm which implements Algorithm #2 of Djelassi, Hatim, and Alexander Mitsos. \"A hybrid discretization algorithm with guaranteed feasibility for the global solution of semi-infinite programs.\" Journal of Global Optimization 68.2 (2017): 227-253 should be used.\n\n\n\n\n\n","category":"type"},{"location":"SemiInfinite/semiinfinite/#EAGO.get_sip_optimizer","page":"Semi-Infinite Programming","title":"EAGO.get_sip_optimizer","text":"get_sip_optimizer\n\nSpecifices the optimizer to be used in extension t::EAGO.ExtensionType with algorithm alg::AbstractSIPAlgo in subproblem s::AbstractSubproblemType via the command get_sip_optimizer(t::ExtensionType, alg::AbstractSIPAlgo, s::AbstractSubproblemType).\n\n\n\n\n\n","category":"function"},{"location":"SemiInfinite/semiinfinite/#EAGO.build_model","page":"Semi-Infinite Programming","title":"EAGO.build_model","text":"build_model\n\nCreate the model and variables used with extension t::EAGO.ExtensionType in algorithm a::AbstractSIPAlgo in subproblem s::AbstractSubproblemType via the command build_model(t::ExtensionType, a::AbstractSIPAlgo, s::AbstractSubproblemType, p::SIPProblem).\n\n\n\n\n\n","category":"function"},{"location":"SemiInfinite/semiinfinite/#EAGO.sip_llp!","page":"Semi-Infinite Programming","title":"EAGO.sip_llp!","text":"sip_llp!\n\nSolves the lower level problem for the ith-SIP used with extension t::EAGO.ExtensionType in algorithm a::AbstractSIPAlgo in subproblem s::AbstractSubproblemType via the command  sip_llp!(t::ExtensionType, a::AbstractSIPAlgo, s::AbstractSubproblemType, ..., i, tol).\n\n\n\n\n\n","category":"function"},{"location":"SemiInfinite/semiinfinite/#EAGO.sip_bnd!","page":"Semi-Infinite Programming","title":"EAGO.sip_bnd!","text":"sip_bnd!\n\nSolves the bounding problem for the ith-SIP used with extension t::EAGO.ExtensionType in algorithm a::AbstractSIPAlgo in subproblem s::AbstractSubproblemType via the command sip_bnd!(t::ExtensionType, a::AbstractSIPAlgo, s::AbstractSubproblemType, ..., i, tol).\n\n\n\n\n\n","category":"function"},{"location":"SemiInfinite/semiinfinite/#EAGO.sip_res!","page":"Semi-Infinite Programming","title":"EAGO.sip_res!","text":"sip_res!\n\nSolves the restriction problem for extension t::EAGO.ExtensionType in algorithm a::AbstractSIPAlgo in subproblem s::AbstractSubproblemType via the command sip_res!(t::ExtensionType, a::AbstractSIPAlgo, ...).\n\n\n\n\n\n","category":"function"},{"location":"SemiInfinite/semiinfinite/#EAGO.sip_solve","page":"Semi-Infinite Programming","title":"EAGO.sip_solve","text":"sip_solve\n\nSolve an SIP with decision variable bounds x_l to x_u, uncertain variable bounds p_l to p_u, an objective function of f, and gSIP seminfiniite constraint(s).\n\n\n\n\n\n","category":"function"},{"location":"SemiInfinite/semiinfinite/","page":"Semi-Infinite Programming","title":"Semi-Infinite Programming","text":"Mitsos A (2009). Global optimization of semi-infinite programs via restriction of the right-hand side. Optimization, 60(10-11):1291-1308.\nDjelassi, Hatim, and Alexander Mitsos. A hybrid discretization algorithm with guaranteed feasibility for the global solution of semi-infinite programs. Journal of Global Optimization, 68.2 (2017): 227-253 should be used.","category":"page"},{"location":"McCormick/operators/#**Currently-supported-operators**","page":"Currently supported operators","title":"Currently supported operators","text":"","category":"section"},{"location":"McCormick/operators/","page":"Currently supported operators","title":"Currently supported operators","text":"The operators currently supported are listed below. The operators with a check box have been subject to a large degree of scrutiny and have been implemented for both forward and reverse McCormick relaxations (Wechsung2015). Each McCormick object is associated with a parameter T <: RelaxTag which is either NS for nonsmooth relaxations (Mitsos2009, Scott2011), MV for multivariate relaxations (Tsoukalas2014, Najman2017), and Diff for differentiable relaxations (Khan2016, Khan2018, Khan2019). Conversion between MV, NS, and Diff relax tags are not currently supported. Convex and concave envelopes are used to compute relaxations of univariate functions.","category":"page"},{"location":"McCormick/operators/#**Univariate-McCormick-Operators**","page":"Currently supported operators","title":"Univariate McCormick Operators","text":"","category":"section"},{"location":"McCormick/operators/","page":"Currently supported operators","title":"Currently supported operators","text":"Arbitrarily differentiable relaxations can be constructed for the following operators:","category":"page"},{"location":"McCormick/operators/","page":"Currently supported operators","title":"Currently supported operators","text":"[x] Inverse (inv)\n[x] Logarithms (log, log2, log10)\n[x] Exponential Functions (exp, exp2, exp10)\n[x] Square Root (sqrt)\n[x] Absolute Value (abs)","category":"page"},{"location":"McCormick/operators/","page":"Currently supported operators","title":"Currently supported operators","text":"Both nonsmooth and Whitney-1 (once differentiable) relaxations are supported:","category":"page"},{"location":"McCormick/operators/","page":"Currently supported operators","title":"Currently supported operators","text":"[x] Step Functions (step, sign)\n[x] Trignometric Functions (sin, cos, tan)\n[x] Inverse Trignometric Functions (asin, acos, atan)\n[x] Hyperbolic Functions (sinh, cosh, tanh)\n[x] Inverse Hyperbolic Functions (asinh, acosh, atanh)\n[x] Common Activation Functions (relu, leakyrelu, paramrelu, sigmoid, bisigmoid,                                      softsign, softplus, maxtanh, pentanh,                                      GeLU, ELU, SELU, Swish-1)\n[x] Special Functions (erf)","category":"page"},{"location":"McCormick/operators/#**Bivariate-Operators:-McCormick-and-McCormick**","page":"Currently supported operators","title":"Bivariate Operators: McCormick & McCormick","text":"","category":"section"},{"location":"McCormick/operators/","page":"Currently supported operators","title":"Currently supported operators","text":"The following bivariant operators are supported for two MC objects. Both nonsmooth and Whitney-1 (once differentiable) relaxations are supported.","category":"page"},{"location":"McCormick/operators/","page":"Currently supported operators","title":"Currently supported operators","text":"[x] multiplication (*)\n[x] division (/)","category":"page"},{"location":"McCormick/operators/","page":"Currently supported operators","title":"Currently supported operators","text":"Arbitrarily differentiable relaxations can be constructed for the following operators:","category":"page"},{"location":"McCormick/operators/","page":"Currently supported operators","title":"Currently supported operators","text":"[x] addition (+)\n[x] subtraction (-)\n[x] minimization (min)\n[x] maximization (max)","category":"page"},{"location":"McCormick/operators/#Activation-Functions-Supported","page":"Currently supported operators","title":"Activation Functions Supported","text":"","category":"section"},{"location":"McCormick/operators/","page":"Currently supported operators","title":"Currently supported operators","text":"relu\nleaky_relu\nparam_relu\nsigmoid\nbisigmoid\nsoftsign\nsoftplus\nmaxtanh\nmaxsig\npentanh\ngelu\nelu\nselu\nswish1","category":"page"},{"location":"McCormick/operators/#McCormick.relu","page":"Currently supported operators","title":"McCormick.relu","text":"relu\n\nThe Rectified Linear Unit (ReLU) activation function relu(x) = max(x, 0.0).\n\n\n\n\n\n","category":"function"},{"location":"McCormick/operators/#McCormick.leaky_relu","page":"Currently supported operators","title":"McCormick.leaky_relu","text":"leaky_relu\n\nThe leaky Rectified Linear Unit activation function leaky_relu(x) = max(x, 0.01x).\n\n\n\n\n\n","category":"function"},{"location":"McCormick/operators/#McCormick.param_relu","page":"Currently supported operators","title":"McCormick.param_relu","text":"param_relu\n\nThe parametric Rectified Linear Unit activation function param_relu(x, α) = (max(x, αx) with α in [0,1].\n\n\n\n\n\n","category":"function"},{"location":"McCormick/operators/#McCormick.sigmoid","page":"Currently supported operators","title":"McCormick.sigmoid","text":"sigmoid\n\nThe sigmoid activation function sigmoid(x) = 1.0/(1.0 + exp(-x)).\n\n\n\n\n\n","category":"function"},{"location":"McCormick/operators/#McCormick.bisigmoid","page":"Currently supported operators","title":"McCormick.bisigmoid","text":"bisigmoid\n\nThe bisigmoid activation function bisigmoid(x) = (1.0 - exp(-x))/(1.0 + exp(-x)).\n\n\n\n\n\n","category":"function"},{"location":"McCormick/operators/#McCormick.softsign","page":"Currently supported operators","title":"McCormick.softsign","text":"softsign\n\nThe softsign activation function softsign(x) = x/(1.0 + abs(x)).\n\n\n\n\n\n","category":"function"},{"location":"McCormick/operators/#McCormick.softplus","page":"Currently supported operators","title":"McCormick.softplus","text":"softplus\n\nThe softplus activation function  softplus(x) = log(1.0 + exp(x)).\n\n\n\n\n\n","category":"function"},{"location":"McCormick/operators/#McCormick.maxtanh","page":"Currently supported operators","title":"McCormick.maxtanh","text":"maxtanh\n\nThe maxtanh activation function  maxtanh(x) = max(x, tanh(x)).\n\n\n\n\n\n","category":"function"},{"location":"McCormick/operators/#McCormick.maxsig","page":"Currently supported operators","title":"McCormick.maxsig","text":"maxsig\n\nThe maxsig activation function  maxsig(x) = max(x, 1.0/(1.0 + exp(-x))).\n\n\n\n\n\n","category":"function"},{"location":"McCormick/operators/#McCormick.pentanh","page":"Currently supported operators","title":"McCormick.pentanh","text":"pentanh\n\nThe pentanh activation function pentanh(x) = x > 0.0 ? tanh(x) : tanh(0.25*x).\n\n\n\n\n\n","category":"function"},{"location":"McCormick/operators/#McCormick.gelu","page":"Currently supported operators","title":"McCormick.gelu","text":"gelu\n\nThe Gaussian Error Linear Unit gelu activation function gelu(x) = x/(1.0 + abs(x)).\n\n\n\n\n\n","category":"function"},{"location":"McCormick/operators/#McCormick.elu","page":"Currently supported operators","title":"McCormick.elu","text":"elu\n\nThe Exponential Linear Unit (ELU) activation function  elu(x, α) = x > 0 ? x : α*(exp(x) - 1.0).\n\n\n\n\n\n","category":"function"},{"location":"McCormick/operators/#McCormick.selu","page":"Currently supported operators","title":"McCormick.selu","text":"selu\n\nThe Scaled Exponential Linear Unit (SELU) activation function  selu(x, α, λ) = λ*elu(x, α).\n\n\n\n\n\n","category":"function"},{"location":"McCormick/operators/#McCormick.swish1","page":"Currently supported operators","title":"McCormick.swish1","text":"swish1\n\nThe Swish-1 activation function swish1(x) = x/(1.0 + exp(-x)).\n\n\n\n\n\n","category":"function"},{"location":"McCormick/operators/#Common-subexpressions","page":"Currently supported operators","title":"Common subexpressions","text":"","category":"section"},{"location":"McCormick/operators/","page":"Currently supported operators","title":"Currently supported operators","text":"The following functions can be used in place of common subexpressions encountered in optimization and will result in improved performance (standard McCormick composition rules are often more expansive in each case).","category":"page"},{"location":"McCormick/operators/","page":"Currently supported operators","title":"Currently supported operators","text":"xexpax\narh\nxlogx","category":"page"},{"location":"McCormick/operators/#McCormick.xexpax","page":"Currently supported operators","title":"McCormick.xexpax","text":"expax\n\nThe expax function is defined as expax(x, a) = x*exp(a*x).\n\nForm defined in Najman, Jaromił, Dominik Bongartz, and Alexander Mitsos. \"Relaxations of thermodynamic property and costing models in process engineering.\" Computers & Chemical Engineering 130 (2019): 106571.\n\n\n\n\n\n","category":"function"},{"location":"McCormick/operators/#McCormick.arh","page":"Currently supported operators","title":"McCormick.arh","text":"arh\n\nThe arrhenius function arh is defined as arh(x) = exp(-k/x).\n\n\n\n\n\n","category":"function"},{"location":"McCormick/operators/#McCormick.xlogx","page":"Currently supported operators","title":"McCormick.xlogx","text":"xlogx\n\nThe function xlogx is defined as xlogx(x) = x*log(x).\n\n\n\n\n\n","category":"function"},{"location":"McCormick/operators/#Bound-Setting-Functions","page":"Currently supported operators","title":"Bound Setting Functions","text":"","category":"section"},{"location":"McCormick/operators/","page":"Currently supported operators","title":"Currently supported operators","text":"The following functions are used to specify that known bounds on a subexpression exist and that the relaxation/interval bounds propagated should make use of this information. The utility functions can be helpful in avoiding domain violations that arise due to the overly expansive nature of composite relaxations. Improper use of these functions may lead to cases in which the resulting relaxations are empty, so the user is encouraged to use discretion.","category":"page"},{"location":"McCormick/operators/","page":"Currently supported operators","title":"Currently supported operators","text":"positive\nnegative\nlower_bnd\nupper_bnd\nbnd","category":"page"},{"location":"McCormick/operators/#McCormick.positive","page":"Currently supported operators","title":"McCormick.positive","text":"positive(x::MC)\n\nSets the lower interval bound and the convex relaxation of x to a value of at least McCormick.MC_DOMAIN_TOL. (Sub)gradients are adjusted appropriately.\n\n\n\n\n\n","category":"function"},{"location":"McCormick/operators/#McCormick.negative","page":"Currently supported operators","title":"McCormick.negative","text":"negative(x::MC)\n\nSets the upper interval bound and the concave relaxation of x to a value of at most -McCormick.MC_DOMAIN_TOL. (Sub)gradients are adjusted appropriately.\n\n\n\n\n\n","category":"function"},{"location":"McCormick/operators/#McCormick.lower_bnd","page":"Currently supported operators","title":"McCormick.lower_bnd","text":"lower_bnd(x::MC, lb::Float64)\n\nSets the lower interval bound and the convex relaxation of x to a value of at least lb. (Sub)gradients are adjusted appropriately.\n\n\n\n\n\n","category":"function"},{"location":"McCormick/operators/#McCormick.upper_bnd","page":"Currently supported operators","title":"McCormick.upper_bnd","text":"upper_bnd(x::MC, ub)\n\nSets the upper interval bound and the concave relaxation of x to a value of at most ub. (Sub)gradients are adjusted appropriately.\n\n\n\n\n\n","category":"function"},{"location":"McCormick/operators/#McCormick.bnd","page":"Currently supported operators","title":"McCormick.bnd","text":"bnd(x::MC, lb, ub)\n\nSets the lower interval bound and the convex relaxation of x to a value of at least lb. Sets the upper interval bound and the concave relaxation of x to a value of at most ub. (Sub)gradients are adjusted appropriately.\n\n\n\n\n\n","category":"function"},{"location":"McCormick/operators/#References","page":"Currently supported operators","title":"References","text":"","category":"section"},{"location":"McCormick/operators/","page":"Currently supported operators","title":"Currently supported operators","text":"Khan KA, Watson HAJ, Barton PI (2017). Differentiable McCormick relaxations. Journal of Global Optimization, 67(4):687-729.\nKhan KA, Wilhelm ME, Stuber MD, Cao H, Watson HAJ, Barton PI (2018). Corrections to: Differentiable McCormick relaxations. Journal of Global Optimization, 70(3):705-706.\nKhan KA (2019). Whitney differentiability of optimal-value functions for bound-constrained convex programming problems. Optimization 68(2-3): 691-711\nMitsos A, Chachuat B, and Barton PI. (2009). McCormick-based relaxations of algorithms. SIAM Journal on Optimization, 20(2):573–601.\nNajman J, Bongratz D, Tsoukalas A, and Mitsos A (2017). Erratum to: Multivariate McCormick relaxations. Journal of Global Optimization, 68:219-225.\nScott JK,  Stuber MD, and Barton PI. (2011). Generalized McCormick relaxations. Journal of Global Optimization, 51(4):569–606.\nStuber MD, Scott JK, Barton PI (2015). Convex and concave relaxations of implicit functions. Optim. Methods Softw. 30(3), 424–460\nTsoukalas A and Mitsos A (2014). Multivariate McCormick Relaxations. Journal of Global Optimization, 59:633–662.\nWechsung A, Scott JK, Watson HAJ, and Barton PI. (2015). Reverse propagation of McCormick relaxations. Journal of Global Optimization 63(1):1-36.","category":"page"},{"location":"McCormick/type/#**Types**","page":"Types","title":"Types","text":"","category":"section"},{"location":"McCormick/type/","page":"Types","title":"Types","text":"McCormick.MC\nMcCormick.RelaxTag","category":"page"},{"location":"McCormick/type/#McCormick.MC","page":"Types","title":"McCormick.MC","text":"struct MC{N, T<:RelaxTag} <: Real\n\nMC{N, T <: RelaxTag} <: Real is the McCormick (w/ (sub)gradient) structure which is used to overload standard calculations. The fields are:\n\ncv::Float64\nConvex relaxation\ncc::Float64\nConcave relaxation\nIntv::Interval{Float64}\nInterval bounds\ncv_grad::SArray{Tuple{N},Float64,1,N} where N\n(Sub)gradient of convex relaxation\ncc_grad::SArray{Tuple{N},Float64,1,N} where N\n(Sub)gradient of concave relaxation\ncnst::Bool\nBoolean indicating whether the relaxations are constant over the domain. True if bounding an interval/constant.      False, otherwise. This may change over the course of a calculation cnst for zero(x) is true even if x.cnst      is false.\n\n\n\n\n\n","category":"type"},{"location":"McCormick/type/#McCormick.RelaxTag","page":"Types","title":"McCormick.RelaxTag","text":"abstract type RelaxTag\n\nAn abstract type the subtypes of which define the manner of relaxation that will be performed for each operator applied to the MC object. Currently, the struct NS which specifies that standard (Mitsos 2009) are to be used is fully supported. Limited support is provided for differentiable McCormick relaxations specified by struct Diff (Khan 2017) and struct MV struct MV (Tsoukalas 2011.) A rounding-safe implementation of the standard McCormick relaxations is specified by the struct NSSafe which is work in progress.\n\n\n\n\n\n","category":"type"},{"location":"McCormick/type/#**Constructors-for-MC**","page":"Types","title":"Constructors for MC","text":"","category":"section"},{"location":"McCormick/type/","page":"Types","title":"Types","text":"MC{N,T}(y::Float64)","category":"page"},{"location":"McCormick/type/#McCormick.MC-Union{Tuple{Float64}, Tuple{T}, Tuple{N}} where T where N","page":"Types","title":"McCormick.MC","text":"MC{N,T}(y::Interval{Float64})\n\nConstructs McCormick relaxation with convex relaxation equal to y.lo and concave relaxation equal to y.hi.\n\n\n\n\n\nMC{N,T}(y::Float64)\n\nConstructs McCormick relaxation with convex relaxation equal to y and concave relaxation equal to y.\n\n\n\n\n\nMC{N,T}(cv::Float64, cc::Float64)\n\nConstructs McCormick relaxation with convex relaxation equal to cv and concave relaxation equal to cc.\n\n\n\n\n\nMC{N,T}(val::Float64, Intv::Interval{Float64}, i::Int64)\n\nConstructs McCormick relaxation with convex relaxation equal to val, concave relaxation equal to val, interval bounds of Intv, and a unit subgradient with nonzero's ith dimension of length N.\n\n\n\n\n\n","category":"method"},{"location":"McCormick/type/#**Internal-Utilities**","page":"Types","title":"Internal Utilities","text":"","category":"section"},{"location":"McCormick/type/","page":"Types","title":"Types","text":"mid3\nmid3v\nmid_grad\ndline_seg\nseed_gradient\ncut\nsecant\nnewton\nMcCormick.golden_section_it\nMcCormick.golden_section","category":"page"},{"location":"McCormick/type/#McCormick.mid3","page":"Types","title":"McCormick.mid3","text":"mid3(x::Float64, y::Float64, z::Float64) -> Tuple{Float64,Int64}\n\n\nCalculates the middle of three numbers returning the value and the index where x >= y.\n\n\n\n\n\n","category":"function"},{"location":"McCormick/type/#McCormick.mid3v","page":"Types","title":"McCormick.mid3v","text":"mid3v(x::Float64, y::Float64, z::Float64) -> Float64\n\n\nCalculates the middle of three numbers (x,y,z) returning the value where x <= y.\n\n\n\n\n\n","category":"function"},{"location":"McCormick/type/#McCormick.mid_grad","page":"Types","title":"McCormick.mid_grad","text":"mid_grad(cc_grad::SArray{Tuple{N},Float64,1,N}, cv_grad::SArray{Tuple{N},Float64,1,N}, id::Int64) -> Any\n\n\nTakes the concave relaxation gradient 'ccgrad', the convex relaxation gradient 'cvgrad', and the index of the midpoint returned 'id' and outputs the appropriate gradient according to McCormick relaxation rules.\n\n\n\n\n\n","category":"function"},{"location":"McCormick/type/#McCormick.dline_seg","page":"Types","title":"McCormick.dline_seg","text":"dline_seg(f::Function, df::Function, x::Float64, xL::Float64, xU::Float64) -> Tuple{Any,Any}\n\n\nCalculates the value of the slope line segment between (xL, f(xL)) and (xU, f(xU)) defaults to evaluating the derivative of the function if the interval is tight.\n\n\n\n\n\n","category":"function"},{"location":"McCormick/type/#McCormick.seed_gradient","page":"Types","title":"McCormick.seed_gradient","text":"seed_gradient(j::Int64, x::Val{N}) -> Any\n\n\nCreates a x::SVector{N,Float64} object that is one at x[j] and zero everywhere else.\n\n\n\n\n\n","category":"function"},{"location":"McCormick/type/#McCormick.cut","page":"Types","title":"McCormick.cut","text":"cut(xL::Float64, xU::Float64, cv::Float64, cc::Float64, cv_grad::SArray{Tuple{N},Float64,1,N}, cc_grad::SArray{Tuple{N},Float64,1,N}) -> Tuple{Float64,Float64,Any,Any}\n\n\nRefines convex/concave relaxations cv and cc with associated subgradients cv_grad and cc_grad by intersecting them with the interval boudns xL and xU.\n\n\n\n\n\n","category":"function"},{"location":"McCormick/type/#McCormick.secant","page":"Types","title":"McCormick.secant","text":"secant(x0::Float64, x1::Float64, xL::Float64, xU::Float64, f::Function, envp1::Float64, envp2::Float64) -> Tuple{Float64,Bool}\n\n\nDefines a local 1D secant method to solve for the root of f between the bounds xL and xU using x0 and x1 as a starting points. The inputs envp1 and envp2 are the envelope calculation parameters.\n\n\n\n\n\n","category":"function"},{"location":"McCormick/type/#McCormick.newton","page":"Types","title":"McCormick.newton","text":"newton(x0::Float64, xL::Float64, xU::Float64, f::Function, df::Function, envp1::Float64, envp2::Float64) -> Tuple{Any,Bool}\n\n\nDefines a local 1D newton method to solve for the root of f between the bounds xL and xU using x0 as a starting point. The derivative of f is df. The inputs envp1 and envp2 are the envelope calculation parameters.\n\n\n\n\n\n","category":"function"},{"location":"McCormick/type/#McCormick.golden_section_it","page":"Types","title":"McCormick.golden_section_it","text":"golden_section_it(init::Int64, a::Float64, fa::Float64, b::Float64, fb::Float64, c::Float64, fc::Float64, f::Function, envp1::Float64, envp2::Float64) -> Float64\n\n\nDefine iteration used in golden section method. The inputs fa,fb, and fc, are the function f evaluated at a,b, and c respectively. The inputs envp1 and envp2 are the envelope calculation parameters. The value init is the iteration number of the golden section method.\n\n\n\n\n\n","category":"function"},{"location":"McCormick/type/#McCormick.golden_section","page":"Types","title":"McCormick.golden_section","text":"golden_section(xL::Float64, xU::Float64, f::Function, envp1::Float64, envp2::Float64) -> Float64\n\n\nDefines a local 1D golden section method to solve for the root of f between the bounds xL and xU using x0 as a starting point. Define iteration used in golden section method. The inputs envp1 and envp2 are the envelope calculation parameters.\n\n\n\n\n\n","category":"function"},{"location":"McCormick/usage/#Basic-Usage","page":"Basic Usage","title":"Basic Usage","text":"","category":"section"},{"location":"McCormick/usage/#**Bounding-a-function-via-McCormick-operators**","page":"Basic Usage","title":"Bounding a function via McCormick operators","text":"","category":"section"},{"location":"McCormick/usage/","page":"Basic Usage","title":"Basic Usage","text":"In order to bound a function using a McCormick relaxation. You first construct structure that bounds the input variables then you construct pass these variables two a function.","category":"page"},{"location":"McCormick/usage/","page":"Basic Usage","title":"Basic Usage","text":"In the example below, convex/concave relaxations of the function f(x) = sin(2x) + exp(x) - x are calculated at x = 1 on the interval [-2,3].","category":"page"},{"location":"McCormick/usage/","page":"Basic Usage","title":"Basic Usage","text":"using EAGO, IntervalArithmetic\n\n# create MC object for x = 2.0 on [1.0,3.0] for relaxing\n# a function f(x) on the interval Intv\n\nf(x) = x*(x-5.0)*sin(x)\n\nx = 2.0                          # value of independent variable x\nIntv = Interval(1.0,4.0)         # define interval to relax over\n\n# create McCormick object\nxMC = MC{1,NS}(x,Intv,1)\n\nfMC = f(xMC)             # relax the function\n\ncv = fMC.cv              # convex relaxation\ncc = fMC.cc              # concave relaxation\ncvgrad = fMC.cv_grad     # subgradient/gradient of convex relaxation\nccgrad = fMC.cc_grad     # subgradient/gradient of concave relaxation\nIv = fMC.Intv           # retrieve interval bounds of f(x) on Intv","category":"page"},{"location":"McCormick/usage/","page":"Basic Usage","title":"Basic Usage","text":"The plotting the results we can easily generate visual the convex and concave relaxations, interval bounds, and affine bounds constructed using the subgradient at the middle of X.","category":"page"},{"location":"McCormick/usage/","page":"Basic Usage","title":"Basic Usage","text":"(Image: Figure_1)","category":"page"},{"location":"McCormick/usage/","page":"Basic Usage","title":"Basic Usage","text":"If we instead use the constructor xMC = MC{1,Diff}(x,Intv,1) in the above code, and then re-plot we arrive at the below graph","category":"page"},{"location":"McCormick/usage/","page":"Basic Usage","title":"Basic Usage","text":"(Image: Figure_2)","category":"page"},{"location":"McCormick/usage/","page":"Basic Usage","title":"Basic Usage","text":"This can readily be extended to multivariate functions as shown below","category":"page"},{"location":"McCormick/usage/","page":"Basic Usage","title":"Basic Usage","text":"\nf(x) = max(x[1],x[2])\n\nx = [2.0 1.0]                                    # values of independent variable x\nIntv = [Interval(-4.0,5.0), Interval(-5.0,3.0)]  # define intervals to relax over\n\n# create McCormick object\nxMC = [MC{2,Diff}(x[i], Intv[i], i) for i=1:2)]\n\nfMC = f(xMC)            # relax the function\n\ncv = fMC.cv              # convex relaxation\ncc = fMC.cc              # concave relaxation\ncvgrad = fMC.cv_grad     # subgradient/gradient of convex relaxation\nccgrad = fMC.cc_grad     # subgradient/gradient of concave relaxation\nIv = fMC.Intv            # retrieve interval bounds of f(x) on Intv","category":"page"},{"location":"McCormick/usage/","page":"Basic Usage","title":"Basic Usage","text":"(Image: Figure_3)","category":"page"},{"location":"cite/#Citing-EAGO","page":"Citing EAGO","title":"Citing EAGO","text":"","category":"section"},{"location":"cite/","page":"Citing EAGO","title":"Citing EAGO","text":"Please cite the following paper when using EAGO.jl:","category":"page"},{"location":"cite/","page":"Citing EAGO","title":"Citing EAGO","text":" M. E. Wilhelm & M. D. Stuber (2020) EAGO.jl: easy advanced global optimization in Julia, \n Optimization Methods and Software, DOI: 10.1080/10556788.2020.1786566 ","category":"page"},{"location":"McCormick/overview/#Overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"McCormick/overview/","page":"Overview","title":"Overview","text":"EAGO provides a library of McCormick relaxations in native Julia code. It supports relaxing functions using both nonsmooth McCormick relaxations (Mitsos2009, Scott2011), smooth McCormick relaxations (Khan2016, Khan2018, Khan2019), multi-variant McCormick relaxations (Tsoukalas2014. A variant of subgradient-based interval refinement (Najman2017)) is supported in the EAGO optimizer. For functions with arbitrarily differentiable relaxations, the differentiable constant μ can be modified by adjusting a constant value in the package. Additionally, and nonvalidated validated interval bounds are supported via IntervalArithmetic.jl which is reexported. The basic McComick operator and reverse McCormick operator (Wechsung2015) libraries are included in two dependent subpackages which can loaded and used independently:","category":"page"},{"location":"McCormick/overview/","page":"Overview","title":"Overview","text":"McCormick.jl: A library of forward-mode and implciit McCormick operators.\nReverseMcCormick.jl: A reverse-mode McCormick operator library.","category":"page"},{"location":"McCormick/overview/#NaN-Numerics","page":"Overview","title":"NaN Numerics","text":"","category":"section"},{"location":"McCormick/overview/","page":"Overview","title":"Overview","text":"When a relaxation is computed at an undefined point or over an unbounded domain, the resulting relaxation is defined as not a number rather than throwing an error. This allows for algorithms to check for these case without resulting to try-catch statements. Moreover, when the interval domain is extensive enough to cause a domain violation an x::MC structure is returned that satisfies isnan(x) === true.","category":"page"},{"location":"McCormick/overview/","page":"Overview","title":"Overview","text":"Khan KA, Watson HAJ, Barton PI (2017). Differentiable McCormick relaxations. Journal of Global Optimization, 67(4):687-729.\nKhan KA, Wilhelm ME, Stuber MD, Cao H, Watson HAJ, Barton PI (2018). Corrections to: Differentiable McCormick relaxations. Journal of Global Optimization, 70(3):705-706.\nKhan KA (2019). Whitney differentiability of optimal-value functions for bound-constrained convex programming problems. Optimization 68(2-3): 691-711\nMitsos A, Chachuat B, and Barton PI. (2009). McCormick-based relaxations of algorithms. SIAM Journal on Optimization, 20(2):573–601.\nNajman J, Bongratz D, Tsoukalas A, and Mitsos A (2017). Erratum to: Multivariate McCormick relaxations. Journal of Global Optimization, 68:219-225.\nScott JK,  Stuber MD, and Barton PI. (2011). Generalized McCormick relaxations. Journal of Global Optimization, 51(4):569–606.\nStuber MD, Scott JK, Barton PI (2015). Convex and concave relaxations of implicit functions. Optim. Methods Softw. 30(3), 424–460\nTsoukalas A and Mitsos A (2014). Multivariate McCormick Relaxations. Journal of Global Optimization, 59:633–662.\nWechsung A, Scott JK, Watson HAJ, and Barton PI. (2015). Reverse propagation of McCormick relaxations. Journal of Global Optimization 63(1):1-36.","category":"page"},{"location":"Optimizer/high_performance/#High-Performance-Configuration","page":"High-Performance Configuration","title":"High-Performance Configuration","text":"","category":"section"},{"location":"Optimizer/high_performance/#LP-Solver-Selection","page":"High-Performance Configuration","title":"LP Solver Selection","text":"","category":"section"},{"location":"Optimizer/high_performance/","page":"High-Performance Configuration","title":"High-Performance Configuration","text":"By default, EAGO uses GLPK for solving linear subproblems introduced. Using a commercial linear solver is highly recommended such as Gurobi, CPLEX, or XPRESS is highly recommended. Both Gurobi and CPLEX are free for academics and installation information can be found through http://www.gurobi.com/academia/academia-center and https://www.ibm.com/developerworks/community/blogs/jfp/entry/CPLEXIsFreeForStudents?lang=en, respectively.","category":"page"},{"location":"Optimizer/high_performance/","page":"High-Performance Configuration","title":"High-Performance Configuration","text":"warning: Warning\nEAGO assumes that the MOI wrapper for any sub-solver exhibits the expected behavior. Any deviation for the expected may lead to an error. We currently recommend using either the default GLPK solver or Gurobi rather than CPLEX. Our experience has been that the GLPK and Gurobi MathOptInterface wrappers are better maintained and less prone to unexpected behavior than CPLEX currently is (though this is continuously improving) and in particular GLPK is quite stable.","category":"page"},{"location":"Optimizer/high_performance/","page":"High-Performance Configuration","title":"High-Performance Configuration","text":"A non-default LP solver can then be selected by the user via a series of keyword argument inputs as illustrated in the code snippet below. The relaxed_optimizer contains an instance optimizer with valid relaxations that are made at the root node and is updated with affine relaxations in place.","category":"page"},{"location":"Optimizer/high_performance/","page":"High-Performance Configuration","title":"High-Performance Configuration","text":"\n# Create opt EAGO Optimizer with Gurobi as a lower subsolver\nm = Model(optimizer_with_attributes(EAGO.Optimizer, \"relaxed_optimizer\" => Gurobi.Optimizer(OutputFlag=0))","category":"page"},{"location":"Optimizer/high_performance/#Rounding-Mode","page":"High-Performance Configuration","title":"Rounding Mode","text":"","category":"section"},{"location":"Optimizer/high_performance/","page":"High-Performance Configuration","title":"High-Performance Configuration","text":"The IntervalArithmetic.jl package supports a number of different directed rounding modes. The default directed rounding mode is :tight. It is recommended that the user specify that :accurate directed rounding mode be used as it may results in a significant performance  improvement. Setting a rounding mode can requires the redefinition of a number of functions. As a result, this should only be done at the top-level by the user (rather than by using keyword arguments). To set the rounding mode to :accurate using the following syntax when loading the EAGO package initially:","category":"page"},{"location":"Optimizer/high_performance/","page":"High-Performance Configuration","title":"High-Performance Configuration","text":"using IntervalArithmetic; setrounding(Interval, :accurate)\nusing EAGO\n# REST OF CODE","category":"page"},{"location":"Optimizer/high_performance/#Ipopt-Build","page":"High-Performance Configuration","title":"Ipopt Build","text":"","category":"section"},{"location":"Optimizer/high_performance/","page":"High-Performance Configuration","title":"High-Performance Configuration","text":"Ipopt is the recommended solver for upper bounding problems. Ipopt's performance is highly dependent on the linear algebra package used (up to 30x). By default MUMPS is used. It's recommended that you either compile Ipopt with HSL MA57 or the Pardiso linear algebra packages with a machine specific Blas library (for Intel users the JuliaPro MKL version is recommended). For information on this, see the below links:","category":"page"},{"location":"Optimizer/high_performance/","page":"High-Performance Configuration","title":"High-Performance Configuration","text":"Compiling Ipopt: https://www.coin-or.org/Ipopt/documentation/node13.html\nJulia Specifics:\nPointing Ipopt to a compiled version:\nIpopt Package Info: https://github.com/JuliaOpt/Ipopt.jl\nDiscourse discussion: https://discourse.julialang.org/t/use-ipopt-with-custom-version/9176\nIssues using Pardiso:\nUbuntu: https://github.com/JuliaOpt/Ipopt.jl/issues/106\nWindows: https://github.com/JuliaOpt/Ipopt.jl/issues/83\nHSL Website: http://www.hsl.rl.ac.uk/ipopt/\nPardiso Website: https://pardiso-project.org/","category":"page"},{"location":"Optimizer/starting/#Solving-simple-example:-an-artificial-neural-network-with-EAGO","page":"Solving simple example: an artificial neural network with EAGO","title":"Solving simple example: an artificial neural network with EAGO","text":"","category":"section"},{"location":"Optimizer/starting/","page":"Solving simple example: an artificial neural network with EAGO","title":"Solving simple example: an artificial neural network with EAGO","text":"Matthew Wilhelm   Department of Chemical and Biomolecular Engineering, University of Connecticut","category":"page"},{"location":"Optimizer/starting/","page":"Solving simple example: an artificial neural network with EAGO","title":"Solving simple example: an artificial neural network with EAGO","text":"In [1,2], a surrogate ANN model of bioreactor productivity was constructed by fitting results from computationally expensive CFD simulations. The author then optimized this surrogate model to obtain ideal processing conditions. This optimization problem is given by:","category":"page"},{"location":"Optimizer/starting/#Input-parameters","page":"Solving simple example: an artificial neural network with EAGO","title":"Input parameters","text":"","category":"section"},{"location":"Optimizer/starting/","page":"Solving simple example: an artificial neural network with EAGO","title":"Solving simple example: an artificial neural network with EAGO","text":"In the first block, we input parameters values supplied in the paper for W, B, D, and X into Julia as simple array objects.","category":"page"},{"location":"Optimizer/starting/","page":"Solving simple example: an artificial neural network with EAGO","title":"Solving simple example: an artificial neural network with EAGO","text":"using JuMP, EAGO\n\n# Box constraints for input variables\nxLBD = [0.623   0.093   0.259   6.56   1114   0.013   0.127   0.004]\nxUBD = [5.89    0.5     1.0     90     25000  0.149   0.889   0.049]\n\n# Weights associated with the hidden layer\nW = [ 0.54  -1.97  0.09  -2.14  1.01  -0.58  0.45  0.26;\n     -0.81  -0.74  0.63  -1.60 -0.56  -1.05  1.23  0.93;\n     -0.11  -0.38 -1.19   0.43  1.21   2.78 -0.06  0.40]\n\n# Weights associated with the output layer\nD = [-0.91 0.11 0.52]\n\n# Bias associated with the hidden layer\nB1 = [-2.698 0.012 2.926]\n\n# Bias associated with the output layer\nB2 = -0.46","category":"page"},{"location":"Optimizer/starting/#Construct-the-JuMP-model-and-optimize","page":"Solving simple example: an artificial neural network with EAGO","title":"Construct the JuMP model and optimize","text":"","category":"section"},{"location":"Optimizer/starting/","page":"Solving simple example: an artificial neural network with EAGO","title":"Solving simple example: an artificial neural network with EAGO","text":"We now formulate the problem using standard JuMP[3] syntax and optimize it. Note that we are forming an NLexpression object to handle the summation term to keep the code visually simple but this could be placed directly in the JuMP expressions instead.","category":"page"},{"location":"Optimizer/starting/","page":"Solving simple example: an artificial neural network with EAGO","title":"Solving simple example: an artificial neural network with EAGO","text":"# Model construction\nmodel = Model(optimizer_with_attributes(EAGO.Optimizer, \"absolute_tolerance\" => 0.001))\n@variable(model, xLBD[i] <= x[i=1:8] <= xUBD[i])\n@NLexpression(model, prop[i=1:3], B1[i] + sum(W[i,j]*x[i] for j in 1:8))\n@NLobjective(model, Max, B2 + sum(D[i]*(2/(1+exp(-2*prop[i]))) for i=1:3))\n\n# Solves the model\noptimize!(model)","category":"page"},{"location":"Optimizer/starting/#Retrieve-results","page":"Solving simple example: an artificial neural network with EAGO","title":"Retrieve results","text":"","category":"section"},{"location":"Optimizer/starting/","page":"Solving simple example: an artificial neural network with EAGO","title":"Solving simple example: an artificial neural network with EAGO","text":"We then recover the objective value, the solution value, and termination status codes using standard JuMP syntax.","category":"page"},{"location":"Optimizer/starting/","page":"Solving simple example: an artificial neural network with EAGO","title":"Solving simple example: an artificial neural network with EAGO","text":"# Access calculated values\nfval = JuMP.objective_value(model)\nxsol = JuMP.value.(x)\nstatus_term = JuMP.termination_status(model)\nstatus_prim = JuMP.primal_status(model)\n\nprintln(\"EAGO terminated with a status of $status_term and a result code of $status_prim\")\nprintln(\"The optimal value is: $fval, the solution found is $xsol.\")","category":"page"},{"location":"Optimizer/starting/#Reference:","page":"Solving simple example: an artificial neural network with EAGO","title":"Reference:","text":"","category":"section"},{"location":"Optimizer/starting/","page":"Solving simple example: an artificial neural network with EAGO","title":"Solving simple example: an artificial neural network with EAGO","text":"J. D. Smith, A. A. Neto, S. Cremaschi, and D. W. Crunkleton, CFD-based optimization of a flooded bed algae bioreactor, Industrial & Engineering Chemistry Research, 52 (2012), pp. 7181–7188\nA. M. Schweidtmann and A. Mitsos. Global Deterministic Optimization with Artificial Neural Networks Embedded https://arxiv.org/pdf/1801.07114.pdf\nIain Dunning and Joey Huchette and Miles Lubin. JuMP: A Modeling Language for Mathematical Optimization, SIAM Review, 59 (2017), pp. 295-320.","category":"page"},{"location":"ref/#**References**","page":"References","title":"References","text":"","category":"section"},{"location":"ref/#*Branch-and-Bound*","page":"References","title":"Branch and Bound","text":"","category":"section"},{"location":"ref/","page":"References","title":"References","text":"Floudas, CA (2013). Deterministic global optimization: theory, methods and applications. Vol. 37. Springer Science & Business Media.\nHorst, R, Tuy, H (2013). Global optimization: Deterministic approaches. Springer Science & Business Media.","category":"page"},{"location":"ref/#*Parametric-Interval-Techniques*","page":"References","title":"Parametric Interval Techniques","text":"","category":"section"},{"location":"ref/","page":"References","title":"References","text":"Hansen ER, Walster GW (2004). Global Optimization Using Interval Analysis. Marcel Dekker, New York, second edition.\nKrawczyk R (1969). Newton-algorithmen zur bestimmung con nullstellen mit fehler-schranken. Computing, 4:187–201.\nKrawczyk R (1984). Interval iterations for including a set of solutions. Computing, 32:13–31.\nMiranda C (1940). Un’osservatione su un teorema di brower. Boll. Un. Mat. Ital., 3:5–7.\nNeumaier A (1990). Interval Methods for Systems of Equations. Cambridge University Press, Cambridge.\nMoore RE (1977). A test for existence of solutions to nonlinear systems. SIAM Journal on Numerical Analysis, 14(4):611–615.","category":"page"},{"location":"ref/#*Domain-Reduction*","page":"References","title":"Domain Reduction","text":"","category":"section"},{"location":"ref/","page":"References","title":"References","text":"Benhamou F, & Older WJ (1997). Applying interval arithmetic to real, integer, and boolean constraints. The Journal of Logic Programming, 32, 1–24.\nCaprara A, & Locatelli M (2010). Global optimization problems and domain reduction strategies. Mathematical Programming, 125, 123–137.\nGleixner AM, Berthold T, Müller B, & Weltge S (2016). Three enhancements for optimization-based bound tightening. ZIB Report, 15–16.\nRyoo HS, & Sahinidis NV (1996). A branch-and-reduce approach to global optimization. Journal of Global Optimization, 8, 107–139.\nSchichl H, & Neumaier A (2005). Interval analysis on directed acyclic graphs for global optimization. Journal of Global Optimization, 33, 541–562.\nTawarmalani, M, & Sahinidis, NV (2005). A polyhedral branch-and-cut approach to global optimization. Mathematical Programming, 103, 225–249.\nVu, X, Schichl, H, & Sam-Haroud, D (2009). Interval propagation and search on directed acyclic graphs for numerical constraint solving. Journal of Global Optimization, 45, 499–531.","category":"page"},{"location":"ref/#*Generalized-McCormick-Relaxations*","page":"References","title":"Generalized McCormick Relaxations","text":"","category":"section"},{"location":"ref/","page":"References","title":"References","text":"Chachuat, B (2014). MC++: a toolkit for bounding factorable functions, v1.0. Retrieved 2 July 2014 https://projects.coin-or.org/MCpp\nMitsos A, Chachuat B, and Barton PI. (2009). McCormick-based relaxations of algorithms. SIAM Journal on Optimization, 20(2):573–601.\nMcCormick, GP (1976).. Computability of global solutions to factorable nonconvex programs: Part I-Convex underestimating problems. Mathematical Programming, 10:147–175.\nMcCormick, GP (1983). Nonlinear programming: Theory, Algorithms, and Applications. Wiley, New York.\nScott JK,  Stuber MD, and Barton PI. (2011). Generalized McCormick relaxations. Journal of Global Optimization, 51(4):569–606.\nStuber MD, Scott JK, Barton PI (2015). Convex and concave relaxations of implicit functions. Optim. Methods Softw. 30(3), 424–460\nTsoukalas A and Mitsos A (2014). Multivariate McCormick Relaxations. Journal of Global Optimization, 59:633–662.\nKhan KA, Watson HAJ, Barton PI (2017). Differentiable McCormick relaxations. Journal of Global Optimization, 67(4):687-729.\nWechsung A, Scott JK, Watson HAJ, and Barton PI. (2015). Reverse propagation of McCormick relaxations. Journal of Global Optimization 63(1):1-36.","category":"page"},{"location":"ref/#*Semi-Infinite-Programming*","page":"References","title":"Semi-Infinite Programming","text":"","category":"section"},{"location":"ref/","page":"References","title":"References","text":"Mitsos A (2009). Global optimization of semi-infinite programs via restriction of the right-hand side. Optimization, 60(10-11):1291-1308.\nStuber MD and Barton PI (2015). Semi-Infinite Optimization With Implicit Functions. Industrial & Engineering Chemistry Research, 54:307-317, 2015.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"(Image: full_Logo)","category":"page"},{"location":"#**EAGO-Easy-Advanced-Global-Optimization-in-Julia**","page":"Introduction","title":"EAGO - Easy Advanced Global Optimization in Julia","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"A flexible-framework for global and robust optimization in Julia","category":"page"},{"location":"#Authors","page":"Introduction","title":"Authors","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Matthew Wilhelm, Department of Chemical and Biomolecular Engineering,  University of Connecticut (UCONN)","category":"page"},{"location":"#Overview","page":"Introduction","title":"Overview","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"EAGO is a global and robust optimization platform based on McCormick relaxations. It contains the first widely accessible global optimization routine based on generalized McCormick relaxations. With the exception of calls to local solvers and linear algebra routines, EAGO is written entirely in native Julia. The solver is quite flexibly arranged so the end user can easily customize low-level routines.","category":"page"},{"location":"#Installing-EAGO","page":"Introduction","title":"Installing EAGO","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"EAGO is registered Julia package. It can be installed using the Julia package manager. From the Julia REPL, type ] to enter the Pkg REPL mode and run the following command","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"pkg> add EAGO","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Currently, EAGO is tied to a 0.21.2+ or greater version of JuMP. This allows a replication of some of the internal features shared by EAGO and JuMP's AD scheme aka generation of Wergert Tapes pass evaluators between JuMP and EAGO etc.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"pkg> add JuMP","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"EAGO v0.4 is the current version requires Julia 1.2+. Use with version 1.4 is recommended as the majority of in-house testing has occured using this version of Julia. The user is directed to the High-Performance Configuration for instructions on how to install a high performance version of EAGO (rather than the basic entirely open-source version). If any issues are encountered when loading EAGO (or when using it), please submit an issue using the Github issue tracker.","category":"page"},{"location":"#Examples","page":"Introduction","title":"Examples","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"A few examples are provided in the documentation website. More involved examples are provided at in the form of Jupyter Notebooks at EAGO-notebooks and can be run using IJulia. To add IJulia","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"pkg> add IJulia","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Then launch the Jupyter notebook using the following command from the Julia terminal,","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> using IJulia; notebook()","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Then simply navigate to the example directory and run the example of most interest.","category":"page"}]
}
